<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Bil-dir</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Markdown and syntax highlighting libraries - cached -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" crossorigin="anonymous">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" crossorigin="anonymous"></script>
    <style>
      :root {
        --bg: #0f1116;
        --panel: #161a22;
        --ink: #e6edf3;
        --muted: #9aa7b2;
        --accent: #6ee7b7;
        --accent-2: #93c5fd;
        --border: #232a36;
        --user: #1d2533;
        --assistant: #121827;
      }
      * { box-sizing: border-box; }
      html, body {
        margin: 0;
        font-family: "IBM Plex Sans", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
        color: var(--ink);
        background: radial-gradient(1200px 600px at 15% -10%, #23304a, transparent),
                    radial-gradient(900px 400px at 95% 10%, #1d3b2f, transparent),
                    var(--bg);
        min-height: 100vh;
      }
      body {
        overflow: hidden;
      }
      header {
        padding: 16px 20px;
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .mobile-only { display: none; }
      body.nav-collapsed main {
        grid-template-columns: 1fr;
      }
      body.nav-collapsed .left-col {
        display: none;
      }
      h1 { margin: 0; font-size: 26px; }
      a { color: var(--accent); text-decoration: none; }
      .icon-btn {
        width: 32px;
        height: 32px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: #0b0f16;
        color: var(--accent);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 16px;
        position: relative;
      }
      .icon-btn.has-alert::after {
        content: "";
        position: absolute;
        top: 5px;
        right: 5px;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #f43f5e;
        border: 1px solid rgba(15, 23, 42, 0.8);
        box-shadow: 0 0 0 2px rgba(244, 63, 94, 0.2);
      }
      .icon-btn svg {
        width: 18px;
        height: 18px;
        display: block;
      }
      .icon-btn.active-nav {
        border-color: var(--accent);
        box-shadow: 0 0 0 1px rgba(126, 223, 135, 0.4);
      }
      #menuToggle {
        font-size: 20px;
        width: 38px;
        height: 38px;
      }
      main {
        display: grid;
        grid-template-columns: 380px 1fr;
        gap: 20px;
        padding: 0 16px 16px;
        max-width: none;
        margin: 0;
        height: calc(100vh - 68px);
        overflow: hidden;
        align-items: stretch;
      }
      .left-col {
        display: flex;
        flex-direction: column;
        gap: 12px;
        height: 100%;
        min-height: 0;
      }
      .panel {
        background: transparent;
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 16px;
        box-shadow: 0 12px 30px rgba(0,0,0,0.2);
        overflow-y: auto;
        max-height: none;
      }
      .left-col .sessions {
        flex: 1;
        min-height: 0;
      }
      .overlay {
        position: fixed;
        inset: 0;
        background: rgba(6, 10, 18, 0.6);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 20;
      }
      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(6, 10, 18, 0.7);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 60;
      }
      .modal {
        position: fixed;
        top: calc(env(safe-area-inset-top, 0px) + 72px);
        left: 50%;
        transform: translate(-50%, 0);
        width: min(560px, 92vw);
        max-height: calc(100vh - 120px);
        background: #0b0f16;
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 16px;
        box-shadow: 0 20px 40px rgba(0,0,0,0.45);
        opacity: 0;
        pointer-events: none;
        z-index: 61;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      .modal.open,
      .modal-overlay.open {
        opacity: 1;
        pointer-events: auto;
      }
      .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 10px;
      }
      .modal-title {
        font-weight: 700;
        font-size: 16px;
      }
      .copy-btn {
        width: 28px;
        height: 28px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #0b0f16;
        color: var(--accent);
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .form-group {
        margin-bottom: 16px;
      }
      .modal form {
        overflow: auto;
        padding-right: 6px;
      }
      .form-group label {
        display: block;
        font-size: 13px;
        font-weight: 600;
        color: var(--muted);
        margin-bottom: 6px;
      }
      .form-group input[type="text"],
      .form-group select {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: #0f141c;
        color: var(--ink);
        font-size: 14px;
        box-sizing: border-box;
      }
      .form-group input[type="text"]:focus,
      .form-group select:focus {
        outline: none;
        border-color: var(--accent);
      }
      .form-group textarea {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: #0f141c;
        color: var(--ink);
        font-size: 14px;
        font-family: inherit;
        box-sizing: border-box;
        resize: vertical;
        min-height: 80px;
      }
      .form-group textarea:focus {
        outline: none;
        border-color: var(--accent);
      }
      .form-group input[type="time"],
      .form-group input[type="number"] {
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: #0f141c;
        color: var(--ink);
        font-size: 14px;
      }
      .checkbox-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 240px;
        overflow: auto;
        padding-right: 6px;
      }
      .checkbox-row {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        color: var(--ink);
      }
      .workdir-row {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 12px;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: #0f141c;
      }
      .workdir-row .workdir-path {
        flex: 1;
        font-size: 13px;
        color: var(--ink);
        word-break: break-all;
      }
      .workdir-row .workdir-path:empty::before,
      .workdir-row .workdir-path[data-empty="true"] {
        color: var(--muted);
      }
      .form-actions {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 20px;
      }
      .btn-primary, .btn-secondary {
        padding: 10px 20px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        border: none;
      }
      .btn-primary {
        background: var(--accent);
        color: #0b0f16;
      }
      .btn-primary:hover {
        filter: brightness(1.1);
      }
      .btn-secondary {
        background: transparent;
        border: 1px solid var(--border);
        color: var(--ink);
      }
      .btn-secondary:hover {
        background: rgba(148, 163, 184, 0.08);
      }
      .id-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        padding: 8px 10px;
        border: 1px solid var(--border);
        border-radius: 6px;
        background: #0b0f16;
        margin-bottom: 8px;
      }
      .id-row code {
        color: var(--ink);
        font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        font-size: 12px;
      }
      .sessions ul {
        list-style: none;
        padding: 0;
        margin: 0;
        overflow: visible;  /* Remove scrollbar from inner list */
      }
      ul.sessions-list {
        overflow: visible;  /* No scrollbar on the list itself */
        max-height: none;   /* Let parent handle scrolling */
      }
      .sessions {
        display: flex;
        flex-direction: column;
        max-height: calc(100vh - 96px);
      }
      .master-card {
        position: sticky;
        top: 0;
        z-index: 2;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 10px 12px;
        box-shadow: 0 8px 20px rgba(0,0,0,0.25);
        margin-bottom: 10px;
      }
      .master-card .session-card {
        border: 0;
        background: transparent;
        padding: 6px 2px;
      }
      .search-panel {
        padding: 0;
        position: sticky;
        top: 0;
        z-index: 5;
        background: none;
        border-radius: 0;
        margin-bottom: 8px;
        border: 0;
        box-shadow: none;
        overflow: visible;
      }
      .search-panel-inner {
        position: relative;
      }
      #navSearch {
        width: 100%;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(12, 18, 28, 0.86);
        color: #e6edf3;
        padding: 10px 12px;
        font-size: 13px;
        min-height: 40px;
        box-shadow: inset 0 0 0 1px rgba(11, 15, 22, 0.6);
        font-weight: 600;
        position: relative;
        z-index: 1;
      }
      #navSearch::placeholder {
        color: rgba(203, 213, 225, 0.95);
        opacity: 1;
        font-weight: 600;
        text-shadow: 0 1px 6px rgba(0,0,0,0.45);
      }
      .sessions-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        margin-bottom: 10px;
      }
      .section-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 10px;
      }
      .section-toggle {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: transparent;
        border: none;
        color: var(--ink);
        font-weight: 700;
        cursor: pointer;
        padding: 0;
      }
      .section-toggle span {
        display: inline-block;
        transition: transform 0.2s ease;
      }
      .section-toggle.collapsed span {
        transform: rotate(-90deg);
      }
      .section-body.collapsed {
        display: none;
      }
      .icon-round {
        width: 32px;
        height: 32px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: #0b0f16;
        color: var(--accent);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 18px;
        line-height: 1;
      }
      .empty-state {
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        text-align: center;
        padding: 40px 20px;
      }
      .empty-state.active {
        display: flex;
      }
      .empty-content h2 {
        color: var(--ink);
        margin-bottom: 12px;
        font-size: 24px;
      }
      .empty-content p {
        color: #6b7280;
        margin-bottom: 24px;
        font-size: 16px;
      }
      .primary-btn {
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        color: #0b0f16;
        border: none;
        padding: 12px 24px;
        border-radius: 10px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .primary-btn:hover {
        opacity: 0.9;
        transform: translateY(-1px);
      }
      .secondary-btn {
        background: transparent;
        color: var(--ink);
        border: 1px solid var(--border);
        padding: 12px 24px;
        border-radius: 10px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .secondary-btn:hover {
        border-color: var(--accent);
      }
      .task-detail-view {
        padding: 20px;
        overflow-y: auto;
      }
      #masterDetailView {
        padding: 14px 16px 8px;
      }
      #masterDetailView .task-header {
        margin-bottom: 12px;
        padding-bottom: 10px;
      }
      .task-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--border);
      }
      .task-header h2 {
        margin: 0;
        color: var(--ink);
      }
      .task-header-actions {
        display: flex;
        gap: 8px;
      }
      .task-edit-form {
        display: flex;
        flex-direction: column;
        gap: 16px;
        max-width: 600px;
      }
      .task-edit-form textarea {
        min-height: 140px;
      }
      .task-edit-form .row {
        display: flex;
        gap: 8px;
      }
      .checkbox-row {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .checkbox-row input[type="checkbox"] {
        width: auto;
        margin: 0;
      }
      .checkbox-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 8px;
        background: rgba(11, 15, 22, 0.5);
        border: 1px solid var(--border);
        border-radius: 10px;
      }
      .schedule-fields {
        display: none;
        flex-direction: column;
        gap: 12px;
        padding: 12px;
        background: rgba(11, 15, 22, 0.3);
        border: 1px solid var(--border);
        border-radius: 10px;
      }
      .schedule-fields.active {
        display: flex;
      }
      .task-output-section {
        margin-top: 32px;
        padding-top: 24px;
        border-top: 1px solid var(--border);
      }
      .task-output-section h3 {
        color: var(--ink);
        margin-bottom: 12px;
      }
      .task-output-section summary {
        color: var(--ink);
        font-weight: 600;
        cursor: pointer;
        margin-bottom: 12px;
        list-style: none;
      }
      .task-output-section summary::-webkit-details-marker { display: none; }
      .task-output-section summary::before {
        content: "▸";
        display: inline-block;
        margin-right: 8px;
        transition: transform 0.2s ease;
        color: var(--muted);
      }
      .task-output-section details[open] summary::before {
        transform: rotate(90deg);
      }
      .task-output-content {
        background: #0b0f16;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 16px;
        color: var(--ink);
        font-size: 14px;
        line-height: 1.5;
        font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        white-space: pre-wrap;
        overflow-x: auto;
        overflow-y: auto;
        max-height: 320px;
      }
      .sessions-list {
        flex: 1;
        min-height: 0;
      }
      .tasks-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .orchestrators-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .tasks-list li {
        padding: 0;
        margin: 0;
        list-style: none;
        border: 1px solid var(--border);
        border-radius: 6px;
        overflow: visible;
      }
      .orchestrators-list li {
        padding: 0;
        margin: 0;
        list-style: none;
        border: 1px solid var(--border);
        border-radius: 6px;
        overflow: visible;
      }
      .tasks-list li.active {
        border-color: var(--accent);
      }
      .task-card {
        border: none;
        border-radius: 6px;
        padding: 10px;
        background: transparent;
        display: flex;
        flex-direction: column;
        gap: 8px;
        text-decoration: none;
        color: inherit;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .orchestrator-card {
        border: none;
        border-radius: 6px;
        padding: 10px;
        background: transparent;
        display: flex;
        flex-direction: column;
        gap: 8px;
        color: inherit;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .task-card:hover {
        background: rgba(110, 231, 183, 0.08);
      }
      .task-card.active {
        background: rgba(110, 231, 183, 0.08);
      }
      .orchestrator-card.active {
        background: rgba(110, 231, 183, 0.08);
      }
      .task-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      .orchestrator-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      .task-meta strong {
        display: block;
      }
      .task-actions {
        display: inline-flex;
        gap: 8px;
        align-items: center;
      }
      .orchestrator-actions {
        display: inline-flex;
        gap: 8px;
        align-items: center;
      }
      .orchestrator-detail {
        color: var(--muted);
        font-size: 12px;
      }
      .orch-toggle-btn {
        border: 1px solid var(--border);
        background: #0b0f16;
        color: var(--ink);
        border-radius: 8px;
        padding: 4px 8px;
        font-size: 11px;
        cursor: pointer;
      }
      .orch-toggle-btn:hover {
        border-color: var(--accent);
        color: var(--accent);
      }
      .orch-delete-btn {
        border: 1px solid rgba(248, 113, 113, 0.6);
        background: rgba(127, 29, 29, 0.2);
        color: #fca5a5;
        border-radius: 8px;
        padding: 4px 8px;
        font-size: 11px;
        cursor: pointer;
      }
      .orch-delete-btn:hover {
        border-color: #ef4444;
        color: #fecaca;
      }
      #orchHistory {
        margin-top: 8px;
      }
      .orch-goal-box {
        background: #0b0f16;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 12px;
      }
      .orch-goal-box textarea {
        width: 100%;
        min-height: 90px;
        background: transparent;
        color: var(--ink);
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 8px;
        padding: 10px;
        font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        font-size: 13px;
        resize: vertical;
      }
      .task-menu .menu-btn {
        width: 28px;
        height: 28px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #0b0f16;
        color: var(--ink);
        cursor: pointer;
        font-size: 14px;
      }
      .task-flyout {
        position: fixed;
        background: #0b0f16;
        border: 1px solid var(--border);
        border-radius: 10px;
        min-width: 100px;
        padding: 6px;
        box-shadow: 0 12px 30px rgba(0,0,0,0.35);
        display: none;
        flex-direction: column;
        align-items: stretch;
        z-index: 9999;
      }
      .task-flyout.open { display: flex; }
      .cancel-btn {
        border: 1px solid #3b475a;
        background: #1b2332;
        color: var(--ink);
      }
      .task-detail {
        color: var(--muted);
        font-size: 12px;
      }
      .task-form {
        border: 1px dashed var(--border);
        border-radius: 10px;
        padding: 10px;
        display: none;
        flex-direction: column;
        gap: 10px;
        margin-top: 8px;
      }
      .task-form.active { display: flex; }
      .task-form textarea {
        min-height: 80px;
      }
      .task-output {
        border-top: 1px solid var(--border);
        padding-top: 8px;
        color: var(--ink);
        font-size: 12px;
        white-space: pre-wrap;
      }
      .task-form .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .sessions li {
        padding: 0;
        border: 1px solid var(--border);
        border-radius: 6px;
        margin-bottom: 8px;
        overflow: visible;
      }
      .session-card {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        padding: 10px;
        color: inherit;
        text-decoration: none;
        background: transparent;
        width: 100%;
        border: none;
        text-align: left;
        cursor: pointer;
      }
      .session-card .meta {
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 0;
      }
      .session-card .meta strong {
        display: block;
      }
      .session-card .provider-tag {
        align-self: flex-start;
      }
      .session-actions {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      .sessions li.active {
        border-color: var(--border);
      }
      .sessions li.active .session-card {
        background: rgba(110, 231, 183, 0.08);
        box-shadow: inset 0 0 0 1px var(--accent);
      }
      .chat {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 96px);
        min-height: 520px;
      }
      .messages {
        flex: 1;
        overflow: auto;
        padding: 8px;
        padding-bottom: 24px;
        background: transparent;
        border-radius: 0;
        border: 0;
        min-height: 0;
      }
      .msg {
        padding: 10px 12px;
        border-radius: 14px;
        margin: 8px 0;
        max-width: 80%;
        word-break: break-word;
      }
      .msg.cli {
        max-width: 100%;
        width: 100%;
        align-self: stretch;
        border-radius: 10px;
      }
      .msg.user { 
        background: var(--user); 
        margin-left: auto;
        text-align: left;
        align-self: flex-end;
        max-width: min(78%, 680px);
        width: fit-content;
      }
      .msg.user.cli {
        margin-left: 0;
        align-self: stretch;
        max-width: 100%;
        width: 100%;
      }
      .msg.assistant { 
        background: var(--assistant);
        line-height: 1.6;
      }
      .msg.assistant.cli {
        background: #0b0f16;
        border: 1px solid rgba(148, 163, 184, 0.25);
      }
      .msg.user.cli {
        background: #0b0f16;
        border: 1px solid rgba(148, 163, 184, 0.18);
      }
      .terminal {
        font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        font-size: 14px;
        line-height: 1.5;
        white-space: pre-wrap;
        color: var(--cli-ink, #e2e8f0);
        overflow-x: hidden;
        overflow-y: hidden;
      }
      .terminal .line {
        display: block;
        word-break: break-word;
        overflow-wrap: anywhere;
      }
      .terminal .line.activity {
        color: var(--cli-activity, #38bdf8);
      }
      .terminal .line.error {
        color: #fca5a5;
      }
      .terminal .line.dim {
        color: var(--cli-dim, #94a3b8);
      }
      .terminal .line.thinking {
        color: var(--cli-dim, #94a3b8);
      }
      .terminal .line.thinking .char {
        display: inline-block;
        animation: thinkingWave 1.4s ease-in-out infinite;
      }
      @keyframes thinkingWave {
        0% { opacity: 0.35; }
        40% { opacity: 1; }
        100% { opacity: 0.35; }
      }
      .terminal .line.heading {
        color: var(--cli-activity, #38bdf8);
        font-weight: 700;
      }
      .terminal .line.quote {
        color: var(--cli-dim, #94a3b8);
      }
      .terminal .line.code {
        color: var(--cli-dim, #94a3b8);
      }
      .terminal .line.code-fence {
        color: var(--cli-activity, #38bdf8);
      }
      .master-prefix {
        font-weight: 700;
        color: var(--session-color, #7fdbff);
      }
      .ansi-bold { font-weight: 700; }
      .ansi-dim { opacity: 0.8; }
      .ansi-fg-black { color: #0f172a; }
      .ansi-fg-red { color: #f87171; }
      .ansi-fg-green { color: #34d399; }
      .ansi-fg-yellow { color: #fbbf24; }
      .ansi-fg-blue { color: #60a5fa; }
      .ansi-fg-magenta { color: #c084fc; }
      .ansi-fg-cyan { color: #22d3ee; }
      .ansi-fg-white { color: #e2e8f0; }
      .ansi-fg-bright-black { color: #94a3b8; }
      .ansi-fg-bright-red { color: #fca5a5; }
      .ansi-fg-bright-green { color: #6ee7b7; }
      .ansi-fg-bright-yellow { color: #fde68a; }
      .ansi-fg-bright-blue { color: #93c5fd; }
      .ansi-fg-bright-magenta { color: #e9d5ff; }
      .ansi-fg-bright-cyan { color: #a5f3fc; }
      .ansi-fg-bright-white { color: #f8fafc; }
      .msg.assistant.cli .terminal,
      .msg.user.cli .terminal {
        background: transparent;
        border: none;
        padding: 0;
        margin: 0;
      }
      .msg.assistant.cli .terminal a,
      .msg.user.cli .terminal a {
        color: var(--cli-activity, #38bdf8);
        text-decoration: underline;
      }
      .task-output-content a {
        color: var(--accent-2);
        text-decoration: underline;
      }
      body[data-provider="claude"] {
        --cli-ink: #e2e8f0;
        --cli-activity: #38bdf8;
        --cli-dim: #94a3b8;
      }
      body[data-provider="codex"] {
        --cli-ink: #dbeafe;
        --cli-activity: #22d3ee;
        --cli-dim: #94a3b8;
      }
      body[data-provider="copilot"] {
        --cli-ink: #e0f2fe;
        --cli-activity: #60a5fa;
        --cli-dim: #94a3b8;
      }
      body[data-provider="gemini"] {
        --cli-ink: #e7f5ff;
        --cli-activity: #a5b4fc;
        --cli-dim: #94a3b8;
      }
      /* Markdown styling for assistant messages */
      .msg.assistant p {
        margin: 0.5em 0;
      }
      .msg.assistant p:first-child {
        margin-top: 0;
      }
      .msg.assistant p:last-child {
        margin-bottom: 0;
      }
      .msg.assistant code {
        background: rgba(110, 231, 183, 0.1);
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 13px;
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      }
      .msg.assistant pre {
        background: #0d1117;
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 12px;
        overflow-x: auto;
        margin: 8px 0;
      }
      .msg.assistant pre code {
        background: transparent;
        padding: 0;
        font-size: 13px;
        line-height: 1.5;
      }
      .msg.assistant ul, .msg.assistant ol {
        margin: 8px 0;
        padding-left: 24px;
      }
      .msg.assistant li {
        margin: 4px 0;
      }
      .msg.assistant blockquote {
        border-left: 3px solid var(--accent);
        padding-left: 12px;
        margin: 8px 0;
        color: var(--muted);
      }
      .msg.assistant h1, .msg.assistant h2, .msg.assistant h3 {
        margin: 12px 0 8px 0;
        color: var(--accent);
      }
      .msg.assistant a {
        color: var(--accent-2);
        text-decoration: underline;
      }
      .msg.assistant table {
        width: max-content;
        max-width: 100%;
        border-collapse: collapse;
        margin: 10px 0;
        display: block;
        overflow-x: auto;
        background: rgba(11, 15, 22, 0.6);
        border: 1px solid var(--border);
        border-radius: 8px;
      }
      .msg.assistant thead {
        background: #0f141c;
        font-weight: 600;
      }
      .msg.assistant th,
      .msg.assistant td {
        padding: 6px 10px;
        border: 1px solid var(--border);
        text-align: left;
        vertical-align: top;
        font-size: 13px;
        white-space: nowrap;
      }
      .msg.assistant tbody tr:nth-child(even) {
        background: rgba(148, 163, 184, 0.06);
      }
      .msg.status-msg {
        background: #0b0f16;
        color: var(--muted);
        font-size: 13px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      details.tools {
        margin-top: 10px;
        background: #0b0f16;
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 8px 10px;
      }
      details.tools summary {
        cursor: pointer;
        color: var(--muted);
        font-size: 13px;
      }
      pre.output {
        white-space: pre-wrap;
        word-break: break-word;
        background: #0b0f16;
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 8px;
        margin: 8px 0 0;
      }
      .messages-shell {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        background: #0b0f16;
        border-radius: 12px;
        border: 1px solid var(--border);
        overflow: hidden;
      }
      .composer {
        display: grid;
        gap: 10px;
        background: transparent;
        padding: 10px;
        border-top: 1px solid var(--border);
      }
      .visually-hidden {
        border: 0;
        clip: rect(0 0 0 0);
        height: 1px;
        margin: -1px;
        overflow: hidden;
        padding: 0;
        position: absolute;
        width: 1px;
      }
      .prompt-row {
        display: flex;
        gap: 10px;
        align-items: flex-end;
        position: relative;
        --prompt-font-size: 15px;
        --prompt-pad-x: 10px;
        --prompt-pad-y: 8px;
      }
      .prompt-row.master-input textarea {
        color: transparent;
        caret-color: var(--ink);
      }
        .prompt-mirror {
          position: absolute;
          pointer-events: none;
          white-space: pre-wrap;
          word-break: break-word;
          font-family: inherit;
          font-size: var(--prompt-font-size);
          line-height: 1.4;
          color: var(--ink);
          padding: var(--prompt-pad-y) var(--prompt-pad-x);
          box-sizing: border-box;
        }
      .master-suggest {
        position: absolute;
        left: 0;
        right: 0;
        bottom: calc(100% + 6px);
        background: #0b0f16;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 6px;
        box-shadow: 0 12px 24px rgba(0,0,0,0.25);
        z-index: 1000;
        display: none;
        max-height: 220px;
        overflow-y: auto;
      }
      .master-suggest.open { display: block; }
      .master-suggest button {
        width: 100%;
        text-align: left;
        padding: 8px 10px;
        border-radius: 8px;
        border: none;
        background: transparent;
        color: var(--ink);
        font-size: 13px;
        cursor: pointer;
      }
      .master-suggest button:hover {
        background: rgba(148, 163, 184, 0.12);
      }
      .prompt-mirror .master-prefix {
        font-weight: 400;
        text-shadow: 0.7px 0 0 currentColor, -0.7px 0 0 currentColor;
        color: var(--session-color, #7fdbff);
      }
      .send-btn {
        width: 32px;
        height: 32px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: #0b0f16;
        color: var(--accent);
        font-weight: 700;
        font-size: 16px;
        line-height: 1;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }
      .send-btn:hover {
        border-color: var(--accent);
      }
      label {
        color: var(--muted);
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.8px;
      }
      input[type="text"], textarea {
        width: 100%;
        padding: 12px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: #0b0f16;
        color: var(--ink);
        font-size: 14px;
      }
      select {
        width: 100%;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: #0b0f16;
        color: var(--ink);
        font-size: 14px;
      }
      textarea { 
        min-height: 34px; 
        resize: none;
        font-family: inherit;
      }
      /* Improved input styling - auto-resize and right-aligned */
      #prompt {
        min-height: 34px;
        max-height: 200px;
        overflow-y: hidden;
        line-height: 1.4;
        font-size: var(--prompt-font-size);
        padding: var(--prompt-pad-y) var(--prompt-pad-x);
        box-sizing: border-box;
      }
      #prompt::-webkit-scrollbar {
        width: 0;
        height: 0;
      }
      button {
        padding: 10px 16px;
        border: none;
        border-radius: 10px;
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        color: #0b0f16;
        font-weight: 600;
        cursor: pointer;
      }
      .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      .muted { color: var(--muted); }
      .resume-btn {
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: #0b0f16;
        color: var(--accent);
        font-size: 12px;
        cursor: pointer;
      }
      .menu-btn {
        width: 30px;
        height: 30px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #0b0f16;
        color: var(--muted);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 18px;
        line-height: 1;
      }
      .session-menu {
        position: relative;
        overflow: visible;
      }
      .menu-panel {
        position: fixed;
        background: #0b0f16;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 6px;
        box-shadow: 0 12px 24px rgba(0,0,0,0.25);
        display: none;
        flex-direction: column;
        z-index: 9999;
        overflow: visible;
      }
      .menu-panel.open { display: inline-flex; }
      .menu-item.has-submenu {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }
      .model-flyout {
        position: fixed;
        background: #0b0f16;
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 6px;
        box-shadow: 0 12px 24px rgba(0,0,0,0.25);
        display: none;
        flex-direction: column;
        z-index: 9999;
      }
      .model-flyout.open { display: inline-flex; }
      .model-hint {
        font-size: 11px;
        color: #64748b;
        margin-left: 6px;
      }
      .menu-item {
        padding: 8px 10px;
        border-radius: 8px;
        border: none;
        background: transparent;
        color: var(--ink);
        text-align: left;
        cursor: pointer;
        font-size: 13px;
        white-space: nowrap;
      }
      .menu-item.danger { color: #fca5a5; }
      .menu-item:hover { background: rgba(148, 163, 184, 0.12); }
      .menu-label {
        padding: 6px 10px 2px;
        color: var(--muted);
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.6px;
      }
      .menu-select {
        width: calc(100% - 12px);
        margin: 0 6px 6px;
      }
      .menu-ids {
        margin: 4px 6px 6px;
        padding: 6px 8px;
        border-radius: 8px;
        background: rgba(148, 163, 184, 0.08);
        border: 1px solid var(--border);
        color: var(--muted);
        font-size: 11px;
        white-space: pre-wrap;
      }
      .hidden { display: none; }
      .provider-tag {
        padding: 4px 8px;
        border-radius: 999px;
        background: #0b0f16;
        border: 1px solid var(--border);
        color: var(--accent-2);
        font-size: 11px;
      }
      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #4b5563;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);
        flex: 0 0 auto;
      }
      .status-dot.running {
        background: var(--accent);
        box-shadow: 0 0 6px rgba(110, 231, 183, 0.7);
        animation: pulse 1.6s ease-in-out infinite;
      }
      .status-dot.error {
        background: #ef4444;
        box-shadow: 0 0 6px rgba(239, 68, 68, 0.7);
      }
      @keyframes pulse {
        0% { box-shadow: 0 0 0 rgba(110, 231, 183, 0.0); }
        50% { box-shadow: 0 0 10px rgba(110, 231, 183, 0.85); }
        100% { box-shadow: 0 0 0 rgba(110, 231, 183, 0.0); }
      }
      .add-session-btn {
        width: 100%;
        margin: 10px 0 14px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        border-radius: 10px;
        border: 1px dashed var(--border);
        background: #0b0f16;
        color: var(--accent);
        font-weight: 600;
        padding: 10px 12px;
        cursor: pointer;
      }
      .status {
        display: flex;
        align-items: center;
        gap: 8px;
        color: var(--muted);
        font-size: 12px;
        min-height: 18px;
      }
      .cwd-row {
        display: flex;
        align-items: center;
        gap: 8px;
        color: var(--muted);
        font-size: 12px;
        margin-top: 6px;
      }
      .cwd-row .cwd-path {
        color: var(--ink);
        font-weight: 600;
        word-break: break-all;
      }
      .cwd-btn {
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: #0b0f16;
        color: var(--accent);
        font-size: 12px;
        cursor: pointer;
      }
      .spinner {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        border: 2px solid rgba(148, 163, 184, 0.3);
        border-top-color: var(--accent);
        animation: spin 0.9s linear infinite;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      @media (max-width: 900px) {
        main { grid-template-columns: 1fr; }
        .chat { height: auto; }
        header {
          position: sticky;
          top: 0;
          z-index: 30;
          backdrop-filter: blur(10px);
        }
        .mobile-only { display: inline-flex; }
        .left-col {
          position: fixed;
          top: 60px;
          left: 0;
          height: calc(100vh - 60px);
          width: min(86vw, 380px);
          transform: translateX(-105%);
          transition: transform 0.25s ease;
          z-index: 25;
          padding: 16px;
          overflow-y: auto;
          background: var(--panel);
          border-right: 1px solid var(--border);
        }
        .search-panel {
          top: 8px;
        }
        .sessions {
          position: static;
          transform: none;
          width: 100%;
          height: auto;
          padding: 0;
          overflow: visible;
          background: transparent;
        }
        .sessions .section-header {
          position: sticky;
          top: -16px;
          background: var(--panel);
          z-index: 10;
          padding: 8px 0;
          margin: 0 0 10px 0;
        }
        .sessions .section-body {
          overflow-y: visible;
          max-height: none;
          min-height: auto;
        }
        .sessions .section-toggle {
          font-size: 16px;
        }
        body.menu-open .left-col {
          transform: translateX(0);
        }
        body.menu-open .overlay {
          opacity: 1;
          pointer-events: auto;
        }
      }
      @media (max-width: 700px) {
        header {
          padding: 12px 14px;
        }
        main {
          padding: 0 12px 16px;
          gap: 14px;
        }
        .chat {
          min-height: auto;
        }
        h1 { font-size: 22px; }
        .panel { padding: 14px; border-radius: 12px; }
        .messages { padding: 8px; }
        .msg { max-width: 100%; }
        textarea { min-height: 34px; }
      }

      /* Custom scrollbars - v2.0 enhanced */
      .messages::-webkit-scrollbar,
      .sessions::-webkit-scrollbar,
      .left-col::-webkit-scrollbar,
      .task-output-content::-webkit-scrollbar,
      .task-edit-form textarea::-webkit-scrollbar,
      #taskCommand::-webkit-scrollbar,
      .task-detail-view::-webkit-scrollbar {
        width: 12px;
        height: 12px;
      }
      .messages::-webkit-scrollbar-track,
      .sessions::-webkit-scrollbar-track,
      .left-col::-webkit-scrollbar-track,
      .task-output-content::-webkit-scrollbar-track,
      .task-edit-form textarea::-webkit-scrollbar-track,
      #taskCommand::-webkit-scrollbar-track,
      .task-detail-view::-webkit-scrollbar-track {
        background: rgba(15, 17, 22, 0.4);
        border-radius: 8px;
        margin: 4px 0;
      }
      .messages::-webkit-scrollbar-thumb,
      .sessions::-webkit-scrollbar-thumb,
      .left-col::-webkit-scrollbar-thumb,
      .task-output-content::-webkit-scrollbar-thumb,
      .task-edit-form textarea::-webkit-scrollbar-thumb,
      #taskCommand::-webkit-scrollbar-thumb,
      .task-detail-view::-webkit-scrollbar-thumb {
        background: rgba(71, 85, 105, 0.4);
        border-radius: 8px;
        border: 2px solid rgba(15, 17, 22, 0.5);
        transition: all 0.2s ease;
      }
      .messages::-webkit-scrollbar-thumb:hover,
      .sessions::-webkit-scrollbar-thumb:hover,
      .left-col::-webkit-scrollbar-thumb:hover,
      .task-output-content::-webkit-scrollbar-thumb:hover,
      .task-edit-form textarea::-webkit-scrollbar-thumb:hover,
      #taskCommand::-webkit-scrollbar-thumb:hover,
      .task-detail-view::-webkit-scrollbar-thumb:hover {
        background: rgba(100, 116, 139, 0.6);
        border-color: rgba(15, 17, 22, 0.7);
      }
      .messages::-webkit-scrollbar-thumb:active,
      .sessions::-webkit-scrollbar-thumb:active,
      .left-col::-webkit-scrollbar-thumb:active,
      .task-output-content::-webkit-scrollbar-thumb:active,
      .task-edit-form textarea::-webkit-scrollbar-thumb:active,
      #taskCommand::-webkit-scrollbar-thumb:active,
      .task-detail-view::-webkit-scrollbar-thumb:active {
        background: rgba(148, 163, 184, 0.7);
      }
      .messages,
      .sessions,
      .left-col,
      .task-output-content,
      .task-edit-form textarea,
      #taskCommand,
      .task-detail-view {
        scrollbar-width: thin;
        scrollbar-color: rgba(71, 85, 105, 0.4) rgba(15, 17, 22, 0.4);
      }
      
      /* Tooltip styling */
      .tooltip-icon {
        display: inline-block;
        width: 16px;
        height: 16px;
        text-align: center;
        line-height: 16px;
        border-radius: 50%;
        background: rgba(100, 116, 139, 0.3);
        color: #94a3b8;
        font-size: 12px;
        cursor: help;
        margin-left: 4px;
      }
      .tooltip-icon:hover {
        background: rgba(100, 116, 139, 0.5);
      }
      
      /* Checkbox styling */
      .form-group input[type="checkbox"] {
        margin-right: 8px;
        cursor: pointer;
      }
    </style>
  </head>
  <body data-selected="{{ selected or '' }}" data-default-workdir="{{ default_workdir or '' }}" data-session-workdir="{{ session_workdir or '' }}" data-master="{{ 'true' if view_mode == 'master' else 'false' }}">
    <header>
      <div class="row">
        <button class="icon-btn" id="menuToggle" type="button" aria-label="Menu" title="Menu">☰</button>
        <h1>Bil-dir</h1>
      </div>
      <div class="row">
        <div class="muted">
          <a class="icon-btn {% if view_mode == 'master' %}active-nav{% endif %}" href="/master" aria-label="Master console" title="Master console">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <circle cx="12" cy="12" r="9" fill="none" stroke="currentColor" stroke-width="1.8"/>
              <path d="M8.5 12h7M12 8.5v7" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/>
            </svg>
          </a>
          <a class="icon-btn {% if gmail_status and not gmail_status.authenticated %}has-alert{% endif %}" href="/config" aria-label="Config" title="Config">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M11.5 2.5h1l.6 2.6c.6.1 1.2.3 1.7.6l2.2-1.5.7.7-1.5 2.2c.3.5.5 1.1.6 1.7l2.6.6v1l-2.6.6c-.1.6-.3 1.2-.6 1.7l1.5 2.2-.7.7-2.2-1.5c-.5.3-1.1.5-1.7.6l-.6 2.6h-1l-.6-2.6c-.6-.1-1.2-.3-1.7-.6l-2.2 1.5-.7-.7 1.5-2.2c-.3-.5-.5-1.1-.6-1.7l-2.6-.6v-1l2.6-.6c.1-.6.3-1.2.6-1.7L5 4.6l.7-.7 2.2 1.5c.5-.3 1.1-.5 1.7-.6l.6-2.6Z" fill="none" stroke="currentColor" stroke-width="1.4" stroke-linejoin="round"/>
              <circle cx="12" cy="12" r="3.2" fill="none" stroke="currentColor" stroke-width="1.6"/>
            </svg>
          </a>
        </div>
      </div>
    </header>
    <div class="overlay" id="menuOverlay"></div>
    <div class="modal-overlay" id="idsOverlay"></div>
    <div class="modal" id="idsModal" role="dialog" aria-modal="true">
      <div class="modal-header">
        <div class="modal-title">Session IDs</div>
        <button class="copy-btn" id="idsCloseBtn" aria-label="Close">✕</button>
      </div>
      <div id="idsBody"></div>
    </div>
    <div class="modal-overlay" id="addSessionOverlay"></div>
    <div class="modal" id="addSessionModal" role="dialog" aria-modal="true">
      <div class="modal-header">
        <div class="modal-title">New Session</div>
        <button class="copy-btn" id="addSessionCloseBtn" aria-label="Close">✕</button>
      </div>
      <form id="addSessionForm">
        <div class="form-group">
          <label for="newSessionName">Session Name</label>
          <input type="text" id="newSessionName" placeholder="Enter session name" required autocomplete="off" />
        </div>
        <div class="form-group">
          <label for="newSessionModel">Model</label>
          <select id="newSessionModel">
            <option value="codex">codex</option>
            <option value="copilot">copilot</option>
            <option value="gemini">gemini</option>
            <option value="claude">claude</option>
          </select>
        </div>
        <div class="form-group">
          <label for="newSessionId">Resume Session ID (optional)</label>
          <input type="text" id="newSessionId" placeholder="Paste existing session ID (from CLI)" autocomplete="off" />
        </div>
        <div class="form-group">
          <label>Working Directory</label>
          <div class="workdir-row">
            <span class="workdir-path" id="newSessionWorkdir">Not set</span>
            <button type="button" class="cwd-btn" id="newSessionPickWorkdir">Choose</button>
            <button type="button" class="cwd-btn" id="newSessionClearWorkdir">Clear</button>
          </div>
          <input type="text" id="newSessionWorkdirManual" placeholder="Or type path manually..." style="margin-top: 8px; display: none;" />
        </div>
        <div class="form-group">
          <label>
            <input type="checkbox" id="newSessionRunInit" disabled />
            Run /init on startup
            <span class="tooltip-icon" title="Automatically generates a context file (COPILOT.md, CLAUDE.md, etc.) by analyzing your codebase. This can take a few minutes depending on the size of the folder.">ⓘ</span>
          </label>
        </div>
        <div class="form-actions">
          <button type="button" class="btn-secondary" id="addSessionCancelBtn">Cancel</button>
          <button type="submit" class="btn-primary">Create</button>
        </div>
      </form>
    </div>
    <div class="modal-overlay" id="addOrchOverlay"></div>
    <div class="modal" id="addOrchModal" role="dialog" aria-modal="true">
      <div class="modal-header">
        <div class="modal-title">New Orchestrator</div>
        <button class="copy-btn" id="addOrchCloseBtn" aria-label="Close">✕</button>
      </div>
      <form id="addOrchForm">
        <div class="form-group">
          <label for="orchName">Name</label>
          <input type="text" id="orchName" placeholder="Enter orchestrator name" required autocomplete="off" />
        </div>
        <div class="form-group">
          <label for="orchProvider">Manager Provider</label>
          <select id="orchProvider">
            {% for p in available_providers %}
            <option value="{{ p }}">{{ p }}</option>
            {% endfor %}
          </select>
        </div>
        <div class="form-group">
          <label for="orchGoal">Goal</label>
          <textarea id="orchGoal" placeholder="Short goal for the orchestrator">Act as a project manager across any task type. Always do the next concrete step toward completion: decide, execute, then report. After every session reply, inject the single most valuable next action (no questions unless truly blocking). Run tests or a quick manual run when relevant, fix errors until the objective is complete, and use MCP tools (e.g., Playwright) to validate outputs or UI. Keep progress moving without waiting for human input.</textarea>
        </div>
        <div class="form-group">
          <label>Managed Sessions</label>
          <div class="checkbox-group" id="orchSessionList">
            {% if session_list %}
              {% for item in session_list %}
              <label class="checkbox-row"><input type="checkbox" value="{{ item.name }}" /> {{ item.name }}</label>
              {% endfor %}
            {% else %}
              <div class="muted">No sessions available.</div>
            {% endif %}
          </div>
        </div>
        <div class="form-group">
          <label>
            <input type="checkbox" id="orchEnabled" checked />
            Start immediately
          </label>
        </div>
        <div class="form-actions">
          <button type="button" class="btn-secondary" id="addOrchCancelBtn">Cancel</button>
          <button type="submit" class="btn-primary">Create</button>
        </div>
      </form>
    </div>
    <div class="modal-overlay" id="addTaskOverlay"></div>
    <div class="modal" id="addTaskModal" role="dialog" aria-modal="true">
      <div class="modal-header">
        <div class="modal-title">New Task</div>
        <button class="copy-btn" id="addTaskCloseBtn" aria-label="Close">✕</button>
      </div>
      <form id="addTaskForm">
        <div class="form-group">
          <label for="modalTaskName">Task Name</label>
          <input type="text" id="modalTaskName" placeholder="Enter task name" required autocomplete="off" />
        </div>
        <div class="form-group">
          <label for="modalTaskPrompt">Prompt</label>
          <textarea id="modalTaskPrompt" placeholder="Enter the prompt for this task" rows="4" required></textarea>
        </div>
        <div class="form-group">
          <label for="modalTaskProvider">Provider</label>
          <select id="modalTaskProvider">
            {% for p in available_providers %}
            <option value="{{ p }}">{{ p }}</option>
            {% endfor %}
          </select>
        </div>
        <div class="form-group">
          <label for="modalTaskScheduleType">Schedule Type</label>
          <select id="modalTaskScheduleType">
            <option value="manual">Manual</option>
            <option value="interval">Interval (minutes)</option>
            <option value="daily">Daily</option>
            <option value="weekly">Weekly</option>
            <option value="once">Once</option>
          </select>
        </div>
        <div class="form-group" id="modalTaskIntervalRow" style="display:none;">
          <label for="modalTaskInterval">Every</label>
          <div class="row">
            <input type="number" id="modalTaskInterval" min="1" value="60" style="width:120px;" />
            <span class="muted">minutes</span>
          </div>
        </div>
        <div class="form-group" id="modalTaskTimeRow" style="display:none;">
          <label for="modalTaskTime">Time</label>
          <input type="time" id="modalTaskTime" />
          <div class="muted">Local time</div>
        </div>
        <div class="form-group" id="modalTaskDaysRow" style="display:none;">
          <label>Days</label>
          <div class="checkbox-group">
            <label class="checkbox-row"><input type="checkbox" value="Mon" class="modal-task-day" /> Mon</label>
            <label class="checkbox-row"><input type="checkbox" value="Tue" class="modal-task-day" /> Tue</label>
            <label class="checkbox-row"><input type="checkbox" value="Wed" class="modal-task-day" /> Wed</label>
            <label class="checkbox-row"><input type="checkbox" value="Thu" class="modal-task-day" /> Thu</label>
            <label class="checkbox-row"><input type="checkbox" value="Fri" class="modal-task-day" /> Fri</label>
            <label class="checkbox-row"><input type="checkbox" value="Sat" class="modal-task-day" /> Sat</label>
            <label class="checkbox-row"><input type="checkbox" value="Sun" class="modal-task-day" /> Sun</label>
          </div>
        </div>
        <div class="form-actions">
          <button type="button" class="btn-secondary" id="addTaskModalCancelBtn">Cancel</button>
          <button type="submit" class="btn-primary">Create Task</button>
        </div>
      </form>
    </div>
    <main>
      <div class="left-col">
        <div class="panel search-panel" id="searchPanel">
          <div class="search-panel-inner">
            <label class="visually-hidden" for="navSearch">Search</label>
            <input id="navSearch" type="text" placeholder="Search sessions, tasks, orchestrators..." autocomplete="off" />
          </div>
        </div>
      <section class="panel sessions">
        <div class="section-header">
          <button class="section-toggle" id="sessionsToggle" type="button" aria-expanded="true">
            <span>▾</span>
            Sessions
          </button>
          <button class="icon-round" id="addSessionBtn" type="button" aria-label="Add session" title="Add session">+</button>
        </div>
        <div class="section-body" id="sessionsBody">
          <ul class="sessions-list">
          {% if session_list %}
            {% for item in session_list %}
            <li class="{% if selected == item.name %}active{% endif %}" data-session-name="{{ item.name }}">
              <a class="session-card" href="/chat/{{ item.name }}">
                <div class="meta">
                  <strong>{{ item.name }}</strong>
                  <span class="provider-tag" data-provider>{{ item.provider }}</span>
                </div>
                <div class="session-actions">
                  <span
                    class="status-dot {% if session_status and session_status.get(item.name) == 'running' %}running{% endif %}"
                    aria-label="status"
                    title="{% if session_status and session_status.get(item.name) == 'running' %}Running{% else %}Idle{% endif %}"
                  ></span>
                  <div class="session-menu" data-menu="{{ item.name }}">
                    <button class="menu-btn" type="button" aria-label="Session menu">⋮</button>
                    <div class="menu-panel" role="menu">
                    <button class="menu-item has-submenu" data-model-menu="{{ item.name }}">Model <span>›</span></button>
                    <button class="menu-item" data-rename="{{ item.name }}">Rename</button>
                    <button class="menu-item" data-show-ids="{{ item.name }}">Session IDs</button>
                    <div class="menu-ids hidden" data-ids-panel="{{ item.name }}"></div>
                    <button class="menu-item danger" data-delete="{{ item.name }}">Delete</button>
                  </div>
                  </div>
                </div>
              </a>
            </li>
            {% endfor %}
          {% else %}
            <li class="muted">No sessions yet.</li>
          {% endif %}
          </ul>
        </div>
        <div class="section-header" style="margin-top:12px;">
          <button class="section-toggle" id="tasksToggle" type="button" aria-expanded="true">
            <span>▾</span>
            Tasks
          </button>
          <button class="icon-round" id="addTaskBtn" type="button" aria-label="Add task" title="Add task">+</button>
        </div>
        <div class="section-body" id="tasksBody">
          <ul class="tasks-list" id="tasksList">
            <li class="muted">No tasks yet.</li>
          </ul>
        </div>
        <div class="section-header" style="margin-top:12px;">
          <button class="section-toggle" id="orchToggle" type="button" aria-expanded="true">
            <span>▾</span>
            Orchestrators
          </button>
          <button class="icon-round" id="addOrchBtn" type="button" aria-label="Add orchestrator" title="Add orchestrator">+</button>
        </div>
        <div class="section-body" id="orchBody">
          <ul class="orchestrators-list" id="orchestratorsList">
            <li class="muted">No orchestrators yet.</li>
          </ul>
        </div>
      </section>
      </div>
      <section class="panel chat">
        {% if view_mode == 'task' and selected_task %}
        <div class="task-detail-view" id="taskDetailView">
          <div class="task-header">
            <h2>{{ selected_task.name }}</h2>
            <div class="task-header-actions">
              {% if task_mentions_gmail and gmail_status and not gmail_status.authenticated %}
              <button class="icon-btn" id="reauthGmailBtn" title="Re-auth Gmail">📧</button>
              {% endif %}
              <button class="icon-btn" id="runTaskBtn" title="Run Now">▶</button>
              <button class="icon-btn" id="deleteTaskBtn" title="Delete Task">🗑</button>
            </div>
          </div>
          {% if task_mentions_gmail and gmail_status and not gmail_status.authenticated %}
          <div class="muted" style="margin-bottom:10px;">
            If Gmail still shows not connected after auth, revoke Google access and try again:
            <a href="https://myaccount.google.com/permissions" target="_blank" rel="noopener">Open Google Permissions</a>
          </div>
          {% endif %}
          <form id="taskEditForm" class="task-edit-form">
            <div>
              <label for="taskName">Task Name</label>
              <input type="text" id="taskName" name="taskName" value="{{ selected_task.name }}" required />
            </div>
            <div>
              <label for="taskCommand">Prompt</label>
              <textarea id="taskCommand" name="taskCommand" required>{{ selected_task.prompt if selected_task.prompt else selected_task.command if selected_task.command else '' }}</textarea>
            </div>
            <div>
              <label for="taskProvider">Provider</label>
              <select id="taskProvider" name="taskProvider">
                {% for p in available_providers %}
                <option value="{{ p }}" {% if selected_task.provider == p %}selected{% endif %}>{{ p|capitalize }}</option>
                {% endfor %}
              </select>
            </div>
            <div>
              <label for="taskWorkdir">Working Directory</label>
              <div class="row">
                <input type="text" id="taskWorkdir" name="taskWorkdir" value="{{ selected_task.workdir or '' }}" />
                <button type="button" class="cwd-btn" id="taskPickWorkdir">Choose</button>
              </div>
            </div>
            <div>
              <label for="taskScheduleType">Schedule Type</label>
              <select id="taskScheduleType" name="taskScheduleType">
                <option value="manual" {% if not selected_task.schedule or selected_task.schedule.type == 'manual' %}selected{% endif %}>Manual</option>
                <option value="once" {% if selected_task.schedule and selected_task.schedule.type == 'once' %}selected{% endif %}>One Time</option>
                <option value="interval" {% if selected_task.schedule and selected_task.schedule.type == 'interval' %}selected{% endif %}>Repeat Every</option>
                <option value="daily" {% if selected_task.schedule and selected_task.schedule.type == 'daily' %}selected{% endif %}>Daily</option>
                <option value="weekly" {% if selected_task.schedule and selected_task.schedule.type == 'weekly' %}selected{% endif %}>Weekly</option>
                <option value="monthly" {% if selected_task.schedule and selected_task.schedule.type == 'monthly' %}selected{% endif %}>Monthly</option>
              </select>
            </div>
            <div id="scheduleOnceFields" class="schedule-fields {% if selected_task.schedule and selected_task.schedule.type == 'once' %}active{% endif %}">
              <label for="taskScheduleDate">Date & Time</label>
              <div class="row">
                <input type="date" id="taskScheduleDate" name="taskScheduleDate" value="{{ selected_task.schedule.date if selected_task.schedule and selected_task.schedule.date else '' }}" />
                <input type="time" id="taskScheduleOnceTime" name="taskScheduleOnceTime" value="{{ selected_task.schedule.time if selected_task.schedule and selected_task.schedule.time else '00:00' }}" />
              </div>
            </div>
            <div id="scheduleIntervalFields" class="schedule-fields {% if selected_task.schedule and selected_task.schedule.type == 'interval' %}active{% endif %}">
              <label for="taskScheduleMinutes">Repeat every</label>
              <div class="row">
                <input type="number" id="taskScheduleMinutes" name="taskScheduleMinutes" min="1" value="{{ selected_task.schedule.minutes if selected_task.schedule and selected_task.schedule.type == 'interval' else 60 }}" style="width: 100px;" />
                <span class="muted">minutes</span>
              </div>
              <label for="taskIntervalStartDate">Start</label>
              <div class="row">
                <input type="date" id="taskIntervalStartDate" name="taskIntervalStartDate" value="{{ selected_task.schedule.start_date if selected_task.schedule and selected_task.schedule.start_date else '' }}" />
                <input type="time" id="taskIntervalStartTime" name="taskIntervalStartTime" value="{{ selected_task.schedule.start_time if selected_task.schedule and selected_task.schedule.start_time else '00:00' }}" />
              </div>
            </div>
            <div id="scheduleDailyFields" class="schedule-fields {% if selected_task.schedule and selected_task.schedule.type == 'daily' %}active{% endif %}">
              <label for="taskScheduleDailyTime">Start time</label>
              <input type="time" id="taskScheduleDailyTime" name="taskScheduleDailyTime" value="{{ selected_task.schedule.time if selected_task.schedule and selected_task.schedule.time else '00:00' }}" />
              <label for="taskDailyStartDate">Start date</label>
              <input type="date" id="taskDailyStartDate" name="taskDailyStartDate" value="{{ selected_task.schedule.start_date if selected_task.schedule and selected_task.schedule.start_date else '' }}" />
              <label for="taskDailyRecur">Recur every</label>
              <div class="row">
                <input type="number" id="taskDailyRecur" name="taskDailyRecur" min="1" value="{{ selected_task.schedule.recur_days if selected_task.schedule and selected_task.schedule.recur_days else 1 }}" style="width: 80px;" />
                <span class="muted">day(s)</span>
              </div>
            </div>
            <div id="scheduleWeeklyFields" class="schedule-fields {% if selected_task.schedule and selected_task.schedule.type == 'weekly' %}active{% endif %}">
              <label for="taskScheduleWeeklyTime">Start time</label>
              <input type="time" id="taskScheduleWeeklyTime" name="taskScheduleWeeklyTime" value="{{ selected_task.schedule.time if selected_task.schedule and selected_task.schedule.time else '00:00' }}" />
              <label for="taskWeeklyStartDate">Start date</label>
              <input type="date" id="taskWeeklyStartDate" name="taskWeeklyStartDate" value="{{ selected_task.schedule.start_date if selected_task.schedule and selected_task.schedule.start_date else '' }}" />
              <label for="taskWeeklyRecur">Recur every</label>
              <div class="row">
                <input type="number" id="taskWeeklyRecur" name="taskWeeklyRecur" min="1" value="{{ selected_task.schedule.recur_weeks if selected_task.schedule and selected_task.schedule.recur_weeks else 1 }}" style="width: 80px;" />
                <span class="muted">week(s)</span>
              </div>
              <label style="margin-top: 12px;">On these days</label>
              <div class="checkbox-group">
                <label class="checkbox-row"><input type="checkbox" name="weekday" value="monday" {% if selected_task.schedule and selected_task.schedule.days and 'monday' in selected_task.schedule.days %}checked{% endif %} /> Monday</label>
                <label class="checkbox-row"><input type="checkbox" name="weekday" value="tuesday" {% if selected_task.schedule and selected_task.schedule.days and 'tuesday' in selected_task.schedule.days %}checked{% endif %} /> Tuesday</label>
                <label class="checkbox-row"><input type="checkbox" name="weekday" value="wednesday" {% if selected_task.schedule and selected_task.schedule.days and 'wednesday' in selected_task.schedule.days %}checked{% endif %} /> Wednesday</label>
                <label class="checkbox-row"><input type="checkbox" name="weekday" value="thursday" {% if selected_task.schedule and selected_task.schedule.days and 'thursday' in selected_task.schedule.days %}checked{% endif %} /> Thursday</label>
                <label class="checkbox-row"><input type="checkbox" name="weekday" value="friday" {% if selected_task.schedule and selected_task.schedule.days and 'friday' in selected_task.schedule.days %}checked{% endif %} /> Friday</label>
                <label class="checkbox-row"><input type="checkbox" name="weekday" value="saturday" {% if selected_task.schedule and selected_task.schedule.days and 'saturday' in selected_task.schedule.days %}checked{% endif %} /> Saturday</label>
                <label class="checkbox-row"><input type="checkbox" name="weekday" value="sunday" {% if selected_task.schedule and selected_task.schedule.days and 'sunday' in selected_task.schedule.days %}checked{% endif %} /> Sunday</label>
              </div>
            </div>
            <div id="scheduleMonthlyFields" class="schedule-fields {% if selected_task.schedule and selected_task.schedule.type == 'monthly' %}active{% endif %}">
              <label for="taskScheduleMonthlyTime">Start time</label>
              <input type="time" id="taskScheduleMonthlyTime" name="taskScheduleMonthlyTime" value="{{ selected_task.schedule.time if selected_task.schedule and selected_task.schedule.time else '00:00' }}" />
              <label for="taskMonthlyStartDate">Start date</label>
              <input type="date" id="taskMonthlyStartDate" name="taskMonthlyStartDate" value="{{ selected_task.schedule.start_date if selected_task.schedule and selected_task.schedule.start_date else '' }}" />
              <label for="taskScheduleDay">Day of month</label>
              <input type="number" id="taskScheduleDay" name="taskScheduleDay" min="1" max="31" value="{{ selected_task.schedule.day if selected_task.schedule and selected_task.schedule.day else 1 }}" />
              <label for="taskMonthlyRecur">Recur every</label>
              <div class="row">
                <input type="number" id="taskMonthlyRecur" name="taskMonthlyRecur" min="1" value="{{ selected_task.schedule.recur_months if selected_task.schedule and selected_task.schedule.recur_months else 1 }}" style="width: 80px;" />
                <span class="muted">month(s)</span>
              </div>
            </div>
            <div class="checkbox-row">
              <input type="checkbox" id="taskEnabled" name="taskEnabled" {% if selected_task.enabled %}checked{% endif %} />
              <label for="taskEnabled">Enabled</label>
            </div>
            <div class="row">
              <button type="submit" class="primary-btn">Save Changes</button>
              <button type="button" class="secondary-btn" id="cancelTaskEdit">Cancel</button>
            </div>
          </form>
          {% if selected_task.output_history_text %}
          <div class="task-output-section" id="taskOutputSection">
            <h3>Output</h3>
            <pre class="task-output-content" id="taskOutputContent">{{ selected_task.output_history_text }}</pre>
          </div>
          {% endif %}
          {% if selected_task.raw_output_history_text %}
          <details class="task-output-section" id="taskRawOutputSection">
            <summary>Raw output</summary>
            <pre class="task-output-content" id="taskRawOutputContent">{{ selected_task.raw_output_history_text }}</pre>
          </details>
          {% endif %}
        </div>
        {% elif view_mode == 'orchestrator' and selected_orchestrator %}
        <div class="task-detail-view" id="orchDetailView">
          <div class="task-header">
            <h2>{{ selected_orchestrator.name }}</h2>
            <div class="task-header-actions">
              <span class="provider-tag" data-provider>{{ selected_orchestrator.provider }}</span>
            </div>
          </div>
          <div class="task-output-section">
            <h3>Goal</h3>
            <div class="orch-goal-box">
              <textarea id="orchGoalEdit" placeholder="Describe the manager's goal...">{{ selected_orchestrator.goal or "" }}</textarea>
              {% if not selected_orchestrator.goal %}
              <div class="muted" style="margin-top:8px;">No goal set.</div>
              {% endif %}
              <div class="row" style="margin-top:10px;">
                <button type="button" class="primary-btn" id="orchSaveBtn">Save goal</button>
              </div>
            </div>
          </div>
          <div class="task-output-section">
            <h3>Managed Sessions</h3>
            <div class="orch-goal-box">
              <div class="checkbox-group" id="orchManagedList">
                {% if session_list %}
                  {% for item in session_list %}
                  <label class="checkbox-row">
                    <input type="checkbox" value="{{ item.name }}" {% if selected_orchestrator.managed_sessions and item.name in selected_orchestrator.managed_sessions %}checked{% endif %} />
                    {{ item.name }}
                  </label>
                  {% endfor %}
                {% else %}
                  <div class="muted">No sessions available.</div>
                {% endif %}
              </div>
              <div class="row" style="margin-top:10px;">
                <button type="button" class="primary-btn" id="orchSaveManagedBtn">Save managed sessions</button>
              </div>
            </div>
          </div>
          <div class="task-output-section">
            <h3>History</h3>
            <pre class="task-output-content">{{ selected_orchestrator.history_text }}</pre>
          </div>
        </div>
        {% elif view_mode == 'master' %}
        <div class="task-detail-view" id="masterDetailView">
          <div class="task-header">
            <h2>Master Console</h2>
            <div class="task-header-actions">
              <span class="muted">Live across all sessions</span>
            </div>
          </div>
        </div>
        <div class="messages-shell">
          <div class="messages" id="messages">
            {% if master_messages %}
              {% for item in master_messages %}
              <div class="msg assistant" data-session-name="{{ item.session_name | e }}" data-master-prefix="@@{{ item.session_name }}: " data-master-started="false" data-raw="{{ item.text | e }}"></div>
              {% endfor %}
            {% endif %}
          </div>
        <form id="chatForm" class="composer">
          <input id="session_name" name="session_name" type="hidden" value="" />
        <div>
          <label class="visually-hidden" for="prompt">Message</label>
          <div class="prompt-row">
            <textarea id="prompt" name="prompt" rows="1" placeholder="@@session-name: message" spellcheck="false"></textarea>
            <button type="submit" class="send-btn" aria-label="Send">↑</button>
          </div>
        </div>
        <select id="providerSelect" name="provider" class="hidden">
          {% for p in available_providers %}
          <option value="{{ p }}">{{ p }}</option>
          {% endfor %}
        </select>
        <input type="checkbox" id="force_new" class="hidden" />
        <div class="cwd-row hidden">
          <span>Working directory:</span>
          <span class="cwd-path" id="cwdLabel"></span>
          <button type="button" class="cwd-btn" id="cwdPickBtn">Choose</button>
        </div>
        <div class="status" id="statusLine"></div>
      </form>
        </div>
        {% else %}
        <div class="empty-state" id="emptyState">
          <div class="empty-content">
            <h2>No Session Selected</h2>
            <p>Create a new session to start chatting with AI assistants</p>
            <button class="primary-btn" id="emptyStateAddBtn">+ Create Session</button>
          </div>
        </div>
        <div class="messages-shell">
          <div class="messages" id="messages"></div>
        <form id="chatForm" class="composer">
          <input id="session_name" name="session_name" type="hidden" value="{{ selected or '' }}" />
        <div>
          <label class="visually-hidden" for="prompt">Message</label>
          <div class="prompt-row">
            <textarea id="prompt" name="prompt" rows="1" placeholder="Type your message..." spellcheck="false"></textarea>
            <button type="submit" class="send-btn" aria-label="Send">↑</button>
          </div>
        </div>
        <select id="providerSelect" name="provider" class="hidden">
          <option value="codex">codex</option>
          <option value="copilot">copilot</option>
          <option value="gemini">gemini</option>
          <option value="claude">claude</option>
        </select>
        <input type="checkbox" id="force_new" class="hidden" />
        <div class="cwd-row">
          <span>Working directory:</span>
          <span class="cwd-path" id="cwdLabel"></span>
          <button type="button" class="cwd-btn" id="cwdPickBtn">Choose</button>
        </div>
        <div class="status" id="statusLine"></div>
      </form>
        </div>
        {% endif %}
    </section>
  </main>
    <script>
      const form = document.getElementById("chatForm");
      const messages = document.getElementById("messages");
      const statusLine = document.getElementById("statusLine");
      const sendButton = form ? form.querySelector("button[type='submit']") : null;
      const promptInput = document.getElementById("prompt");
      const providerSelect = document.getElementById("providerSelect");
      const menuToggle = document.getElementById("menuToggle");
      const menuOverlay = document.getElementById("menuOverlay");
      const sessionsList = document.querySelector(".sessions ul");
      const cwdLabel = document.getElementById("cwdLabel");
      const cwdPickBtn = document.getElementById("cwdPickBtn");
      const defaultWorkdir = document.body.dataset.defaultWorkdir || "";
      const sessionWorkdir = document.body.dataset.sessionWorkdir || "";
      let currentWorkdir = "";
      const idsOverlay = document.getElementById("idsOverlay");
      const idsModal = document.getElementById("idsModal");
      const idsBody = document.getElementById("idsBody");
      const idsCloseBtn = document.getElementById("idsCloseBtn");
      const sessionsToggle = document.getElementById("sessionsToggle");
      const sessionsBody = document.getElementById("sessionsBody");
      const tasksToggle = document.getElementById("tasksToggle");
      const tasksBody = document.getElementById("tasksBody");
      const tasksList = document.getElementById("tasksList");
      const orchToggle = document.getElementById("orchToggle");
      const orchBody = document.getElementById("orchBody");
      const navSearch = document.getElementById("navSearch");
      const searchPanel = document.getElementById("searchPanel");
      const NAV_SCROLL_KEY = "navScrollTop";
      let pendingNavScroll = null;
      const orchestratorsList = document.getElementById("orchestratorsList");
      const addOrchBtn = document.getElementById("addOrchBtn");
      const addOrchOverlay = document.getElementById("addOrchOverlay");
      const addOrchModal = document.getElementById("addOrchModal");
      const addOrchForm = document.getElementById("addOrchForm");
      const addOrchCloseBtn = document.getElementById("addOrchCloseBtn");
      const addOrchCancelBtn = document.getElementById("addOrchCancelBtn");
      const orchNameInput = document.getElementById("orchName");
      const orchProviderSelect = document.getElementById("orchProvider");
      const orchGoalInput = document.getElementById("orchGoal");
      const orchSessionList = document.getElementById("orchSessionList");
      const orchEnabledInput = document.getElementById("orchEnabled");
      const addTaskBtn = document.getElementById("addTaskBtn");
      const addTaskOverlay = document.getElementById("addTaskOverlay");
      const addTaskModal = document.getElementById("addTaskModal");
      const addTaskForm = document.getElementById("addTaskForm");
      const addTaskCloseBtn = document.getElementById("addTaskCloseBtn");
      const addTaskModalCancelBtn = document.getElementById("addTaskModalCancelBtn");
      const modalTaskNameInput = document.getElementById("modalTaskName");
      const modalTaskPromptInput = document.getElementById("modalTaskPrompt");
      const modalTaskProviderSelect = document.getElementById("modalTaskProvider");
      const modalTaskScheduleType = document.getElementById("modalTaskScheduleType");
      const modalTaskIntervalRow = document.getElementById("modalTaskIntervalRow");
      const modalTaskIntervalInput = document.getElementById("modalTaskInterval");
      const modalTaskTimeRow = document.getElementById("modalTaskTimeRow");
      const modalTaskTimeInput = document.getElementById("modalTaskTime");
      const modalTaskDaysRow = document.getElementById("modalTaskDaysRow");
      let editingTaskId = null;
      let taskCache = {};
      let orchCache = {};
      const initialMessages = {{ history_messages|tojson }};
      const initialToolOutputs = {{ history_tools|tojson }};
      const masterMode = document.body.dataset.master === "true";
      const masterMessages = {{ master_messages|tojson if master_messages is defined else "[]" }};
      const sessionNameList = {{ session_list|map(attribute='name')|list|tojson if session_list is defined else "[]" }};
      const orchestratorList = {{ orchestrators|tojson if orchestrators is defined else "[]" }};
      console.log("Loaded history - messages:", initialMessages?.length || 0, "tools:", initialToolOutputs?.length || 0);
      const sessionStatus = {{ session_status|tojson }};
      const selectedProvider = "{{ selected_provider or default_provider }}";
      const selectedSession = document.body.dataset.selected || "";
      const selectedOrchId = "{{ selected_orchestrator.id if selected_orchestrator else '' }}";
      const providerModels = {{ provider_models|tojson }};
      const initialOrchestrators = {{ orchestrators|tojson }};
      consumeNavScroll();
      requestAnimationFrame(() => applyPendingNavScroll());
      setTimeout(() => applyPendingNavScroll(), 250);

      function getNavPanel() {
        return document.querySelector(".sessions");
      }

      function storeNavScroll() {
        const panel = getNavPanel();
        if (!panel) return;
        localStorage.setItem(NAV_SCROLL_KEY, String(panel.scrollTop));
      }

      function consumeNavScroll() {
        const raw = localStorage.getItem(NAV_SCROLL_KEY);
        if (raw == null) return null;
        const value = parseInt(raw, 10);
        if (Number.isNaN(value)) return null;
        pendingNavScroll = value;
        return pendingNavScroll;
      }

      function applyPendingNavScroll() {
        const panel = getNavPanel();
        if (!panel || pendingNavScroll == null) return;
        const maxScroll = Math.max(0, panel.scrollHeight - panel.clientHeight);
        if (pendingNavScroll <= maxScroll) {
          panel.scrollTop = pendingNavScroll;
          pendingNavScroll = null;
        } else {
          panel.scrollTop = maxScroll;
        }
      }

      // Show empty state if no session selected
      const emptyState = document.getElementById("emptyState");
      const chatForm = document.getElementById("chatForm");
      
      function updateEmptyState() {
        const sessionNameEl = document.getElementById("session_name");
        const hasSession = masterMode ? true : (sessionNameEl ? sessionNameEl.value.trim() !== "" : false);
        if (emptyState) {
          emptyState.classList.toggle("active", !hasSession);
        }
        if (chatForm) {
          chatForm.classList.toggle("hidden", !hasSession);
        }
        if (messages) {
          messages.classList.toggle("hidden", !hasSession);
        }
      }
      
      updateEmptyState();

      function scrollToBottom() {
        if (messages) {
          messages.scrollTop = messages.scrollHeight;
        }
      }

      // Configure marked once at startup
      marked.setOptions({
        breaks: true,
        gfm: true,
        highlight: function(code, lang) {
          if (lang && hljs.getLanguage(lang)) {
            try {
              return hljs.highlight(code, { language: lang }).value;
            } catch (err) {}
          }
          return hljs.highlightAuto(code).value;
        }
      });

      const cliMode = true;
      let lastCliMessage = null;
      let currentStreamingMessage = null;
      let currentThinkingLine = null;
      let currentStreamAbort = null;

      function escapeHtml(text) {
        return text
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function linkifyText(text) {
        const urlRe = /(https?:\/\/[^\s<]+|www\.[^\s<]+)/g;
        return text.replace(urlRe, (match) => {
          let url = match;
          let trailing = "";
          while (/[).,!?;:]$/.test(url)) {
            trailing = url.slice(-1) + trailing;
            url = url.slice(0, -1);
          }
          const href = url.startsWith("http") ? url : `http://${url}`;
          return `<a href="${href}" target="_blank" rel="noopener noreferrer">${url}</a>${trailing}`;
        });
      }

      function ansiToHtml(text, options = {}) {
        const re = /\u001b\[([0-9;]*)m/g;
        let result = "";
        let lastIndex = 0;
        let bold = false;
        let dim = false;
        let fg = "";
        const allowRich = options.linkify !== false;

        const colorMap = {
          "30": "ansi-fg-black",
          "31": "ansi-fg-red",
          "32": "ansi-fg-green",
          "33": "ansi-fg-yellow",
          "34": "ansi-fg-blue",
          "35": "ansi-fg-magenta",
          "36": "ansi-fg-cyan",
          "37": "ansi-fg-white",
          "90": "ansi-fg-bright-black",
          "91": "ansi-fg-bright-red",
          "92": "ansi-fg-bright-green",
          "93": "ansi-fg-bright-yellow",
          "94": "ansi-fg-bright-blue",
          "95": "ansi-fg-bright-magenta",
          "96": "ansi-fg-bright-cyan",
          "97": "ansi-fg-bright-white",
        };

        function wrapSegment(segment) {
          if (!segment) return "";
          const classes = [];
          if (bold) classes.push("ansi-bold");
          if (dim) classes.push("ansi-dim");
          if (fg) classes.push(fg);
          let safe = escapeHtml(segment);
          if (allowRich) {
            safe = linkifyText(safe);
            safe = safe.replace(/\*\*(.+?)\*\*/g, '<span class="ansi-bold">$1</span>');
            safe = safe.replace(/__(.+?)__/g, '<span class="ansi-bold">$1</span>');
            safe = safe.replace(/`([^`]+)`/g, '<span class="ansi-fg-bright-cyan">$1</span>');
          }
          if (!classes.length) return safe;
          return `<span class="${classes.join(" ")}">${safe}</span>`;
        }

        let match;
        while ((match = re.exec(text)) !== null) {
          const chunk = text.slice(lastIndex, match.index);
          result += wrapSegment(chunk);
          lastIndex = re.lastIndex;

          const codes = match[1] ? match[1].split(";") : ["0"];
          for (const code of codes) {
            if (code === "0") {
              bold = false;
              dim = false;
              fg = "";
            } else if (code === "1") {
              bold = true;
            } else if (code === "2") {
              dim = true;
            } else if (colorMap[code]) {
              fg = colorMap[code];
            }
          }
        }
        result += wrapSegment(text.slice(lastIndex));
        return result;
      }

      function ensureTerminalBody(container) {
        let pre = container.querySelector(".terminal");
        if (!pre) {
          pre = document.createElement("pre");
          pre.className = "terminal";
          container.appendChild(pre);
        }
        return pre;
      }

      function ensureActivityBody(container) {
        let details = container.querySelector("details.tools");
        if (!details) {
          details = document.createElement("details");
          details.className = "tools";
          const summary = document.createElement("summary");
          summary.textContent = "Activity";
          details.appendChild(summary);
          const pre = document.createElement("pre");
          pre.className = "output";
          details.appendChild(pre);
          container.appendChild(details);
        }
        return details.querySelector("pre");
      }

      function appendTerminalBlock(container, text, kind = "agent", autoScroll = true) {
        if (!container || !text) return;
        const pre = (cliMode && kind === "activity") ? ensureActivityBody(container) : ensureTerminalBody(container);
        let inCodeBlock = container.dataset.codeBlock === "true";
        const prefix = container.dataset.masterPrefix || "";
        const hasPrefix = masterMode && prefix && container.dataset.masterStarted !== "true";
        let prefixUsed = false;
        text.split(/\r?\n/).forEach((line) => {
          const span = document.createElement("span");
          let lineKind = "";
          const trimmed = line.trim();
          if (trimmed.startsWith("```")) {
            lineKind = "code-fence";
            inCodeBlock = !inCodeBlock;
          } else if (inCodeBlock) {
            lineKind = "code";
          } else if (/^#{1,6}\s+/.test(trimmed)) {
            lineKind = "heading";
          } else if (/^\s*(?:[-*+]|\d+\.)\s+/.test(trimmed)) {
            lineKind = "list";
          } else if (/^>\s+/.test(trimmed)) {
            lineKind = "quote";
          }
          span.className = `line ${kind}${lineKind ? ` ${lineKind}` : ""}`;
          const allowRich = !inCodeBlock && lineKind !== "code-fence";
          const hasAnsi = /\x1b\[[0-9;]*m/.test(line);
          const rendered = (!hasAnsi && allowRich && masterMode)
            ? marked.parseInline(line)
            : ansiToHtml(line, { linkify: allowRich });
          if (hasPrefix && !prefixUsed) {
            const prefixSpan = `<span class="master-prefix">${escapeHtml(prefix)}</span>`;
            span.innerHTML = prefixSpan + rendered;
            prefixUsed = true;
          } else {
            span.innerHTML = rendered;
          }
          pre.appendChild(span);
        });
        if (hasPrefix && prefixUsed) {
          container.dataset.masterStarted = "true";
        }
        container.dataset.codeBlock = inCodeBlock ? "true" : "false";
        if (autoScroll) scrollToBottom();
      }

      function addMessage(text, role, skipScroll = false) {
        const div = document.createElement("div");
        div.className = `msg ${role}`;
        if (cliMode) {
          div.classList.add("cli");
          if (role === "assistant") {
            if (text) {
              appendTerminalBlock(div, text, "agent");
            } else {
              ensureTerminalBody(div);
            }
            lastCliMessage = div;
          } else {
            appendTerminalBlock(div, `> ${text || ""}`, "dim");
          }
        } else {
          if (role === "assistant") {
            div.innerHTML = marked.parse(text);
            div.dataset.raw = text || "";
            enhanceTables(div);
          } else {
            div.textContent = text;
          }
        }
        
        messages.appendChild(div);
        if (!skipScroll) {
          scrollToBottom();
        }
        return div;
      }

      function colorForSession(name) {
        let hash = 0;
        for (let i = 0; i < name.length; i++) {
          hash = (hash * 31 + name.charCodeAt(i)) | 0;
        }
        const hue = Math.abs(hash) % 360;
        return `hsl(${hue} 70% 70%)`;
      }

      function enhanceTables(container) {
        if (!container) return;
        const blocks = container.querySelectorAll("pre > code");
        blocks.forEach((code) => {
          const text = code.textContent || "";
          if (!text.trim()) return;
          if (text.includes("|")) return;
          let lines = text.split(/\r?\n/).map((line) => line.trim()).filter(Boolean);
          if (lines.length < 2) return;
          lines = lines.filter((line) => !/^\[\d+\s+rows?\s+x\s+\d+\s+columns\]$/i.test(line));
          lines = lines.filter((line) => !/^-{2,}$/.test(line));
          if (lines.length < 2) return;
          const splitRow = (line) => line.split(/\s{2,}|\t+/).map((cell) => cell.trim()).filter(Boolean);
          const rows = lines.map(splitRow);
          const validRows = rows.filter((row) => row.length >= 2);
          if (validRows.length !== rows.length) return;
          const colCount = Math.max(...rows.map((row) => row.length));
          if (colCount < 2) return;
          const table = document.createElement("table");
          const thead = document.createElement("thead");
          const headRow = document.createElement("tr");
          const headerCells = rows[0];
          headerCells.forEach((cell) => {
            const th = document.createElement("th");
            th.textContent = cell;
            headRow.appendChild(th);
          });
          thead.appendChild(headRow);
          table.appendChild(thead);
          const tbody = document.createElement("tbody");
          rows.slice(1).forEach((row) => {
            const tr = document.createElement("tr");
            row.forEach((cell) => {
              const td = document.createElement("td");
              td.textContent = cell;
              tr.appendChild(td);
            });
            tbody.appendChild(tr);
          });
          table.appendChild(tbody);
          const pre = code.parentElement;
          if (pre) {
            pre.replaceWith(table);
          }
        });
      }

      function addMasterMessage(sessionName, text, skipScroll = false) {
        if (!sessionName || !text) return null;
        const div = addMessage("", "assistant", true);
        div.dataset.masterPrefix = `@@${sessionName}: `;
        div.dataset.masterStarted = "false";
        div.style.setProperty("--session-color", colorForSession(sessionName));
        updateAssistantMessage(div, normalizeMasterText(sessionName, text) + "\n", true);
        if (!skipScroll) scrollToBottom();
        return div;
      }

      function updateAssistantMessage(el, text, append = true) {
        if (!el) return;
        if (cliMode) {
          appendTerminalBlock(el, text, "agent", true);
          return;
        }
        const prev = el.dataset.raw || "";
        const next = append ? (prev + text) : text;
        el.dataset.raw = next;
        el.innerHTML = marked.parse(next);
        enhanceTables(el);
      }

      function normalizeMasterText(sessionName, text) {
        if (!text) return text;
        const prefix = `@@${sessionName}:`;
        const trimmed = text.trimStart();
        if (trimmed.startsWith(prefix)) {
          return trimmed.slice(prefix.length).trimStart();
        }
        return text;
      }

      function appendTool(output) {
        if (cliMode && lastCliMessage) {
          appendTerminalBlock(lastCliMessage, output, "activity");
          return;
        }
        let tools = document.getElementById("toolsPanel");
        if (!tools) {
          tools = document.createElement("details");
          tools.id = "toolsPanel";
          tools.className = "tools";
          const summary = document.createElement("summary");
          summary.textContent = "Activity";
          tools.appendChild(summary);
          const pre = document.createElement("pre");
          pre.className = "output";
          pre.id = "toolsOutput";
          tools.appendChild(pre);
          messages.appendChild(tools);
        }
        const pre = document.getElementById("toolsOutput");
        pre.textContent += output;
        scrollToBottom();
      }

      function appendActivity(panel, text) {
        if (cliMode && lastCliMessage) {
          appendTerminalBlock(lastCliMessage, text, "activity");
          return;
        }
        if (!text || !panel) return;
        const pre = panel.querySelector("pre");
        if (!pre) return;
        pre.textContent += text + "\n";
        scrollToBottom();
      }

      function renderHistory() {
        console.log("renderHistory called, messages:", initialMessages?.length, "tools:", initialToolOutputs?.length);
        if (masterMode) {
          const masterHasInitial = messages && messages.children && messages.children.length > 0;
          if (masterHasInitial) {
            Array.from(messages.children).forEach((el) => {
              const sessionName = el.dataset.sessionName || (el.dataset.masterPrefix || "").replace(/^@@/, '').replace(/: $/, '');
              if (sessionName) {
                el.style.setProperty("--session-color", colorForSession(sessionName));
              }
              const raw = el.dataset.raw || "";
              if (raw) {
                appendTerminalBlock(el, normalizeMasterText(sessionName, raw), "agent", false);
              }
            });
          } else if (Array.isArray(masterMessages) && masterMessages.length) {
            masterMessages.forEach((item) => {
              if (item && item.session_name && item.text) {
                addMasterMessage(item.session_name, item.text, true);
              }
            });
          }
          scrollToBottom();
          return;
        }
        if (Array.isArray(initialMessages)) {
          initialMessages.forEach((msg) => {
            if (msg && msg.text && msg.role) {
              addMessage(msg.text, msg.role, true); // Skip scroll during history load
            }
          });
        }
        if (Array.isArray(initialToolOutputs)) {
          initialToolOutputs.forEach((output) => {
            if (output) {
              if (cliMode) {
                if (lastCliMessage) {
                  appendTerminalBlock(lastCliMessage, output, "activity");
                } else {
                  const toolMsg = addMessage("", "assistant", true);
                  appendTerminalBlock(toolMsg, output, "activity");
                }
              } else {
                appendTool(output);
              }
            }
          });
        }
        collapseActivityPanels();
        scrollToBottom();
      }

      function collapseActivityPanels() {
        document.querySelectorAll("details.tools").forEach((panel) => {
          panel.open = false;
        });
      }

      renderHistory();
      if (masterMode) {
        let masterSnapshotApplied = false;
        const masterSource = new EventSource("/master/stream");
        masterSource.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.type === "snapshot") {
              const masterHasInitial = messages && messages.children && messages.children.length > 0;
              if (!masterSnapshotApplied && !masterHasInitial && (!Array.isArray(masterMessages) || masterMessages.length === 0)) {
                const items = data.messages || [];
                items.forEach((item) => {
                  if (item && item.session_name && item.text) {
                    addMasterMessage(item.session_name, item.text, true);
                  }
                });
                scrollToBottom();
              }
              masterSnapshotApplied = true;
              return;
            }
            if (data.type === "message" && data.session_name && data.text) {
              addMasterMessage(data.session_name, data.text);
            }
          } catch (err) {
            console.error("Master stream error:", err);
          }
        };
      }
      if (providerSelect) {
        const hasOption = (value) => Array.from(providerSelect.options).some((o) => o.value === value);
        if (selectedProvider && hasOption(selectedProvider)) {
          providerSelect.value = selectedProvider;
        } else if (providerSelect.options.length) {
          providerSelect.value = providerSelect.options[0].value;
        }
        providerSelect.disabled = !selectedSession;
      }
      document.body.dataset.provider = (providerSelect && providerSelect.value) ? providerSelect.value : (selectedProvider || "codex");
      document.querySelectorAll(".task-output-content").forEach((el) => {
        if (el.dataset.linkified === "true") return;
        const raw = el.textContent || "";
        el.innerHTML = linkifyText(escapeHtml(raw));
        el.dataset.linkified = "true";
      });

      const orchSaveBtn = document.getElementById("orchSaveBtn");
      const orchGoalEdit = document.getElementById("orchGoalEdit");
      if (orchSaveBtn && orchGoalEdit && selectedOrchId) {
        orchSaveBtn.addEventListener("click", async () => {
          const goal = orchGoalEdit.value.trim();
          try {
            const resp = await fetch(`/orchestrators/${encodeURIComponent(selectedOrchId)}`, {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ goal }),
            });
            if (!resp.ok) {
              const data = await resp.json().catch(() => ({}));
              alert(data.error || "Failed to update goal");
              return;
            }
            refreshOrchestrators();
          } catch (err) {
            console.error("Failed to update goal:", err);
            alert("Failed to update goal");
          }
        });
      }

      const orchSaveManagedBtn = document.getElementById("orchSaveManagedBtn");
      const orchManagedList = document.getElementById("orchManagedList");
      if (orchSaveManagedBtn && orchManagedList && selectedOrchId) {
        orchSaveManagedBtn.addEventListener("click", async () => {
          const managed = Array.from(orchManagedList.querySelectorAll("input[type='checkbox']:checked"))
            .map((cb) => cb.value);
          try {
            const resp = await fetch(`/orchestrators/${encodeURIComponent(selectedOrchId)}`, {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ managed_sessions: managed }),
            });
            if (!resp.ok) {
              const data = await resp.json().catch(() => ({}));
              alert(data.error || "Failed to update managed sessions");
              return;
            }
            refreshOrchestrators();
          } catch (err) {
            console.error("Failed to update managed sessions:", err);
            alert("Failed to update managed sessions");
          }
        });
      }
      
      // Auto-resize textarea as user types
      if (promptInput) {
        function autoResize() {
          promptInput.style.height = 'auto';
          promptInput.style.height = Math.min(promptInput.scrollHeight, 200) + 'px';
          renderPromptMirror();
        }
        
        promptInput.addEventListener('input', autoResize);
        promptInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            chatForm.dispatchEvent(new Event('submit', { bubbles: true, cancelable: true }));
          }
        });
        
        // Initial resize
        autoResize();
      }
      
      if (selectedSession) {
        if (promptInput) {
          promptInput.focus();
        }
        requestAnimationFrame(() => scrollToBottom());
      }

      function setWorkdir(path) {
        currentWorkdir = path || "";
        if (cwdLabel) {
          cwdLabel.textContent = currentWorkdir || defaultWorkdir || "Not set";
        }
        try {
          localStorage.setItem("currentWorkdir", currentWorkdir);
        } catch (err) {
          // ignore
        }
      }

      // Initialize workdir: session-specific > localStorage > default
      try {
        if (sessionWorkdir) {
          setWorkdir(sessionWorkdir);
        } else {
          const saved = localStorage.getItem("currentWorkdir") || "";
          setWorkdir(saved || defaultWorkdir);
        }
      } catch (err) {
        setWorkdir(sessionWorkdir || defaultWorkdir);
      }

      if (cwdPickBtn) {
        cwdPickBtn.addEventListener("click", async () => {
          try {
            const resp = await fetch("/pick-workdir", { method: "POST" });
            if (resp.ok) {
              const data = await resp.json();
              if (data && data.path) {
                setWorkdir(data.path);
                return;
              }
            }
          } catch (err) {
            // fallback below
          }
          const fallback = prompt("Paste the full folder path to use");
          if (fallback) setWorkdir(fallback.trim());
        });
      }

      function wireSectionToggle(toggle, body) {
        if (!toggle || !body) return;
        toggle.addEventListener("click", () => {
          const collapsed = body.classList.toggle("collapsed");
          toggle.classList.toggle("collapsed", collapsed);
          toggle.setAttribute("aria-expanded", String(!collapsed));
        });
      }

      wireSectionToggle(sessionsToggle, sessionsBody);
      wireSectionToggle(tasksToggle, tasksBody);
      wireSectionToggle(orchToggle, orchBody);

      // Task Modal Functions
      function updateModalTaskScheduleFields() {
        const type = modalTaskScheduleType ? modalTaskScheduleType.value : "manual";
        if (modalTaskIntervalRow) modalTaskIntervalRow.style.display = type === "interval" ? "block" : "none";
        if (modalTaskTimeRow) modalTaskTimeRow.style.display = type === "daily" || type === "weekly" || type === "once" ? "block" : "none";
        if (modalTaskDaysRow) modalTaskDaysRow.style.display = type === "weekly" ? "block" : "none";
      }

      function resetModalTaskForm() {
        if (modalTaskNameInput) modalTaskNameInput.value = "";
        if (modalTaskPromptInput) modalTaskPromptInput.value = "";
        if (modalTaskProviderSelect && modalTaskProviderSelect.options.length) {
          modalTaskProviderSelect.value = modalTaskProviderSelect.options[0].value;
        }
        if (modalTaskScheduleType) modalTaskScheduleType.value = "manual";
        if (modalTaskIntervalInput) modalTaskIntervalInput.value = "60";
        if (modalTaskTimeInput) modalTaskTimeInput.value = "";
        document.querySelectorAll(".modal-task-day").forEach((el) => {
          el.checked = false;
        });
        updateModalTaskScheduleFields();
        editingTaskId = null;
      }

      function openAddTaskModal() {
        if (addTaskOverlay) addTaskOverlay.classList.add("open");
        if (addTaskModal) addTaskModal.classList.add("open");
        resetModalTaskForm();
      }

      function closeAddTaskModal() {
        if (addTaskOverlay) addTaskOverlay.classList.remove("open");
        if (addTaskModal) addTaskModal.classList.remove("open");
        resetModalTaskForm();
      }

      if (modalTaskScheduleType) {
        modalTaskScheduleType.addEventListener("change", updateModalTaskScheduleFields);
      }

      if (addTaskBtn) {
        addTaskBtn.addEventListener("click", openAddTaskModal);
      }

      if (addTaskCloseBtn) {
        addTaskCloseBtn.addEventListener("click", closeAddTaskModal);
      }

      if (addTaskModalCancelBtn) {
        addTaskModalCancelBtn.addEventListener("click", closeAddTaskModal);
      }

      if (addTaskOverlay) {
        addTaskOverlay.addEventListener("click", closeAddTaskModal);
      }

      function handleEventLine(line, current, activityPanel) {
        if (line.startsWith("data:")) {
          const text = line.replace("data:", "").trim();
          if (text.startsWith("stdout:")) {
            const raw = text.replace(/^stdout:/, "").trim();
            try {
              const evt = JSON.parse(raw);
              if (evt.type === "item.completed" && evt.item) {
                if (evt.item.type === "agent_message" && evt.item.text) {
                  updateAssistantMessage(current, evt.item.text + "\n");
                } else if (masterMode) {
                  // Skip non-chat activity in master console
                  return;
                } else if (evt.item.type === "reasoning" && evt.item.text) {
                  if (cliMode) {
                    appendTerminalBlock(current, evt.item.text, "activity");
                  } else {
                    appendActivity(activityPanel, evt.item.text);
                  }
                } else if (evt.item.type === "command_execution") {
                  const out = evt.item.aggregated_output || "";
                  if (out) {
                    if (cliMode) {
                      appendTerminalBlock(current, out, "activity");
                    } else {
                      appendTool(out);
                    }
                  }
                } else if (evt.item.text) {
                  if (cliMode) {
                    appendTerminalBlock(current, evt.item.text, "activity");
                  } else {
                    appendActivity(activityPanel, evt.item.text);
                  }
                } else if (evt.item.aggregated_output) {
                  if (cliMode) {
                    appendTerminalBlock(current, evt.item.aggregated_output, "activity");
                  } else {
                    appendTool(evt.item.aggregated_output);
                  }
                }
              }
            } catch (err) {
              if (raw) {
                appendTool(raw + "\n");
              }
            }
          } else if (text.startsWith("stderr:")) {
            const errText = text.replace(/^stderr:/, "").trim();
            if (errText) {
              appendTool(errText + "\n");
            }
          }
        }
      }

      function setWorking(isWorking, text = "") {
        if (isWorking) {
          if (currentStreamingMessage) {
            if (cliMode) {
              if (!currentThinkingLine) {
                const pre = ensureTerminalBody(currentStreamingMessage);
                currentThinkingLine = document.createElement("span");
                currentThinkingLine.className = "line dim thinking";
                pre.appendChild(currentThinkingLine);
              }
              const raw = text || "Thinking...";
              const chars = Array.from(raw);
              currentThinkingLine.innerHTML = chars
                .map((ch, idx) => {
                  const safe = escapeHtml(ch);
                  const delay = (idx * 0.08).toFixed(2);
                  return `<span class="char" style="animation-delay:${delay}s">${safe}</span>`;
                })
                .join("");
            } else {
              let indicator = currentStreamingMessage.querySelector("#thinkingIndicator");
              if (!indicator) {
                indicator = document.createElement("div");
                indicator.id = "thinkingIndicator";
                indicator.className = "status-msg";
                currentStreamingMessage.appendChild(indicator);
              }
              indicator.innerHTML = `<span class="spinner"></span>${text || "Working..."}`;
            }
            scrollToBottom();
          }
          if (sendButton) sendButton.disabled = true;
        } else {
          if (currentThinkingLine) {
            currentThinkingLine.remove();
            currentThinkingLine = null;
          }
          const indicator = currentStreamingMessage ? currentStreamingMessage.querySelector("#thinkingIndicator") : null;
          if (indicator) indicator.remove();
          if (sendButton) sendButton.disabled = false;
        }
      }

      async function streamResponse(payload) {
        const sessionName = payload && payload.session_name ? payload.session_name : selectedSession;
        const hasProvider = payload && Object.prototype.hasOwnProperty.call(payload, "provider");
        const streamProvider = hasProvider ? payload.provider : (providerSelect ? providerSelect.value : "codex");
        document.body.dataset.provider = streamProvider || "codex";
        if (sessionName) {
          applyStatus(sessionName, "running");
          updateProviderSelectState();
        }
        if (payload) {
          const cwd = currentWorkdir || defaultWorkdir;
          if (cwd) {
            payload.cwd = cwd;
          }
        }
        const controller = new AbortController();
        currentStreamAbort = controller;
        try {
          const resp = await fetch("/stream", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
            signal: controller.signal,
          });
          if (!resp.ok || !resp.body) {
            addMessage(`Error: ${resp.status}`, "assistant");
            if (cliMode) {
              if (lastCliMessage) {
                appendTerminalBlock(lastCliMessage, `Error: ${resp.status}`, "error");
              }
            } else {
              appendActivity(`Error: ${resp.status}`);
            }
            if (sessionName) {
              applyStatus(sessionName, "idle");
              updateProviderSelectState();
            }
            setWorking(false);
            return;
          }
          const reader = resp.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";
          const renderStream = !masterMode;
          let activityPanel = null;
          if (!cliMode && renderStream) {
            activityPanel = document.createElement("details");
            activityPanel.className = "tools";
            activityPanel.open = true;
            const summary = document.createElement("summary");
            summary.textContent = "Activity";
            activityPanel.appendChild(summary);
            const pre = document.createElement("pre");
            pre.className = "output";
            activityPanel.appendChild(pre);
            messages.appendChild(activityPanel);
          }
          let current = null;
          if (renderStream) {
            current = addMessage("", "assistant");
            if (sessionName) {
              current.dataset.masterPrefix = `@@${sessionName}: `;
              current.dataset.masterStarted = "false";
            }
          }
          currentStreamingMessage = renderStream ? current : null;
          setWorking(true, "Thinking...");
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            let idx;
            while ((idx = buffer.indexOf("\n\n")) !== -1) {
              const chunk = buffer.slice(0, idx).trim();
              buffer = buffer.slice(idx + 2);
              if (!chunk) continue;
              const lines = chunk.split("\n");
              let chunkEvent = "";
              for (const line of lines) {
                if (line.startsWith("event:")) {
                  chunkEvent = line.replace("event:", "").trim();
                  if (chunkEvent === "done") {
                    setWorking(false);
                    collapseActivityPanels();
                    if (sessionName) {
                      applyStatus(sessionName, "idle");
                      updateProviderSelectState();
                    }
                  } else if (chunkEvent === "error") {
                    setWorking(false, "Error");
                    if (renderStream && current) {
                      if (cliMode) {
                        appendTerminalBlock(current, "Error.", "error");
                      } else {
                        appendActivity(activityPanel, "Error.");
                      }
                    } else if (sessionName) {
                      addMasterMessage(sessionName, "Error.");
                    }
                    collapseActivityPanels();
                    if (sessionName) {
                      applyStatus(sessionName, "idle");
                      updateProviderSelectState();
                    }
                  }
                } else {
                  if (chunkEvent === "error") {
                    const errText = line.replace("data:", "").trim();
                    if (errText) {
                      if (renderStream && current) {
                        if (cliMode) {
                          appendTerminalBlock(current, errText, "error");
                        } else {
                          appendTool(errText + "\n");
                          appendActivity(activityPanel, errText);
                        }
                      } else if (sessionName) {
                        addMasterMessage(sessionName, errText);
                      }
                    }
                  } else if (!chunkEvent || chunkEvent === "message") {
                    if (renderStream) {
                      handleEventLine(line, current, activityPanel);
                    }
                  }
                }
              }
            }
          }
          setWorking(false);
        } catch (err) {
          if (err && err.name === "AbortError") {
            if (sessionName) {
              applyStatus(sessionName, "idle");
              updateProviderSelectState();
            }
          } else {
            addMessage("Error: stream failed.", "assistant");
          }
          setWorking(false);
        } finally {
          currentStreamingMessage = null;
          currentStreamAbort = null;
        }
      }

      function attachToRunning(name) {
        if (!name) return;
        setWorking(true, "Reconnecting...");
        const provider = providerSelect ? providerSelect.value : "codex";
        streamResponse({ session_name: name, provider, attach: true });
      }

      function parseMasterInput(text) {
        if (!text || !text.startsWith("@@")) return null;
        const rest = text.slice(2).trim();
        if (!rest) return null;
        let name = "";
        let message = "";
        const colonIdx = rest.indexOf(":");
        if (colonIdx >= 0) {
          name = rest.slice(0, colonIdx).trim();
          message = rest.slice(colonIdx + 1).trim();
        } else {
          const parts = rest.split(/\s+/);
          name = parts.shift() || "";
          message = parts.join(" ").trim();
        }
        if (!name || !message) return null;
        return { name, message };
      }

      function getOrchestratorByName(name) {
        if (!name || !Array.isArray(orchestratorList)) return null;
        const target = name.toLowerCase();
        return orchestratorList.find((orch) => (orch.name || "").toLowerCase() === target) || null;
      }

      function parseOrchestratorCommand(message) {
        const raw = (message || "").trim();
        if (!raw) return null;
        const lower = raw.toLowerCase();
        if (["pause", "stop", "disable"].includes(lower)) {
          return { action: "pause" };
        }
        if (["start", "run", "enable"].includes(lower)) {
          return { action: "start" };
        }
        if (["status", "info"].includes(lower)) {
          return { action: "status" };
        }
        if (lower.startsWith("goal")) {
          const goal = raw.replace(/^goal\s*[: ]/i, "").trim();
          return goal ? { action: "set_goal", goal } : { action: "help" };
        }
        if (lower.startsWith("set goal")) {
          const goal = raw.replace(/^set\s+goal\s*[: ]/i, "").trim();
          return goal ? { action: "set_goal", goal } : { action: "help" };
        }
        if (lower.startsWith("sessions")) {
          const list = raw.replace(/^sessions\s*[: ]/i, "").trim();
          return list ? { action: "set_sessions", sessions: list } : { action: "help" };
        }
        if (lower.startsWith("set sessions")) {
          const list = raw.replace(/^set\s+sessions\s*[: ]/i, "").trim();
          return list ? { action: "set_sessions", sessions: list } : { action: "help" };
        }
        if (lower === "help" || lower === "?") {
          return { action: "help" };
        }
        return { action: "unknown" };
      }

      function formatOrchHelp() {
        return [
          "Commands:",
          "- start | pause | status",
          "- goal: <text>  (or: set goal: <text>)",
          "- sessions: a, b, c  (or: set sessions: a, b, c)",
        ].join("\n");
      }

      function parseSessionList(text) {
        if (!text) return [];
        if (text.includes(",")) {
          return text.split(",").map((s) => s.trim()).filter(Boolean);
        }
        return text.split(/\s+/).map((s) => s.trim()).filter(Boolean);
      }

      async function handleOrchestratorCommand(orch, command) {
        if (!orch || !command) return;
        const orchName = orch.name || "orchestrator";
        if (command.action === "help" || command.action === "unknown") {
          addMasterMessage(orchName, formatOrchHelp());
          return;
        }
        if (command.action === "status") {
          const status = orch.enabled ? "Enabled" : "Paused";
          const lastAction = orch.last_action || "n/a";
          const lastDecision = orch.last_decision_at || "n/a";
          addMasterMessage(orchName, `Status: ${status}\nLast action: ${lastAction}\nLast decision: ${lastDecision}`);
          return;
        }
        if (command.action === "start") {
          const resp = await fetch(`/orchestrators/${orch.id}/start`, { method: "POST" });
          if (!resp.ok) {
            addMasterMessage(orchName, "Failed to start orchestrator.");
            return;
          }
          orch.enabled = true;
          addMasterMessage(orchName, "Started.");
          return;
        }
        if (command.action === "pause") {
          const resp = await fetch(`/orchestrators/${orch.id}/pause`, { method: "POST" });
          if (!resp.ok) {
            addMasterMessage(orchName, "Failed to pause orchestrator.");
            return;
          }
          orch.enabled = false;
          addMasterMessage(orchName, "Paused.");
          return;
        }
        if (command.action === "set_goal") {
          const resp = await fetch(`/orchestrators/${orch.id}`, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ goal: command.goal }),
          });
          if (!resp.ok) {
            addMasterMessage(orchName, "Failed to update goal.");
            return;
          }
          orch.goal = command.goal;
          addMasterMessage(orchName, "Goal updated.");
          return;
        }
        if (command.action === "set_sessions") {
          const sessions = parseSessionList(command.sessions);
          const resp = await fetch(`/orchestrators/${orch.id}`, {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ managed_sessions: sessions }),
          });
          if (!resp.ok) {
            addMasterMessage(orchName, "Failed to update sessions.");
            return;
          }
          orch.managed_sessions = sessions;
          addMasterMessage(orchName, `Managed sessions updated: ${sessions.join(", ") || "none"}`);
        }
      }

      function getMasterPrefixRange(value) {
        if (!value.startsWith("@@")) return null;
        const colonIdx = value.indexOf(":");
        if (colonIdx === -1) return null;
        const prefix = value.slice(0, colonIdx + 1);
        return { start: 0, end: prefix.length, prefix };
      }

      function getSessionNameList() {
        if (Array.isArray(sessionNameList) && sessionNameList.length) {
          const names = sessionNameList.slice();
          if (Array.isArray(orchestratorList)) {
            orchestratorList.forEach((orch) => {
              if (orch && orch.name && !names.includes(orch.name)) {
                names.push(orch.name);
              }
            });
          }
          return names;
        }
        const names = Array.from(document.querySelectorAll(".sessions-list li[data-session-name]"))
          .map((el) => el.getAttribute("data-session-name") || "")
          .filter(Boolean);
        if (Array.isArray(orchestratorList)) {
          orchestratorList.forEach((orch) => {
            if (orch && orch.name && !names.includes(orch.name)) {
              names.push(orch.name);
            }
          });
        }
        return names;
      }

      function autocompleteSessionName(value) {
        if (!value.startsWith("@@")) return null;
        const after = value.slice(2);
        const match = after.match(/^([^\s:]+)(.*)$/);
        if (!match) return null;
        const partial = match[1];
        const tail = match[2] || "";
        if (!partial) return null;
        const list = getSessionNameList();
        const found = list.find((name) => name.toLowerCase().startsWith(partial.toLowerCase()));
        if (!found) return null;
        const suffix = tail.startsWith(":") || tail.startsWith(" ") ? tail : "";
        if (!suffix) {
          return `@@${found}: `;
        }
        return `@@${found}${suffix}`;
      }

      function renderPromptMirror() {
        if (!masterMode || !promptInput) return;
        const row = promptInput.closest(".prompt-row");
        if (!row) return;
        let mirror = row.querySelector(".prompt-mirror");
          if (!mirror) {
            mirror = document.createElement("div");
            mirror.className = "prompt-mirror";
            row.insertBefore(mirror, promptInput);
            row.classList.add("master-input");
          }
          let suggest = row.querySelector(".master-suggest");
          if (!suggest) {
            suggest = document.createElement("div");
            suggest.className = "master-suggest";
            row.appendChild(suggest);
          }
          const rowRect = row.getBoundingClientRect();
          const inputRect = promptInput.getBoundingClientRect();
          if (rowRect.width && inputRect.width) {
            mirror.style.left = `${inputRect.left - rowRect.left}px`;
            mirror.style.top = `${inputRect.top - rowRect.top}px`;
            mirror.style.width = `${inputRect.width}px`;
            mirror.style.height = `${inputRect.height}px`;
          }
          const value = promptInput.value || "";
          const range = getMasterPrefixRange(value);
        if (range) {
          const rest = value.slice(range.end);
          const name = range.prefix.replace(/^@@/, "").replace(/:$/, "");
          const color = colorForSession(name);
          mirror.innerHTML = `<span class="master-prefix" style="--session-color:${color}">${escapeHtml(range.prefix)}</span>${escapeHtml(rest)}`;
        } else {
          mirror.textContent = value;
        }
      }

      function getMasterSuggestionState(value) {
        if (!value.startsWith("@@")) return null;
        const after = value.slice(2);
        const match = after.match(/^([^\s:]*)(.*)$/);
        if (!match) return null;
        const partial = match[1] || "";
        const tail = match[2] || "";
        return { partial, tail };
      }

      function applyMasterSuggestion(name) {
        if (!promptInput) return;
        const current = promptInput.value || "";
        const state = getMasterSuggestionState(current);
        let tail = state ? state.tail : "";
        let message = "";
        if (tail.startsWith(":")) {
          message = tail.slice(1);
        } else if (tail.startsWith(" ")) {
          message = tail;
        }
        if (message && !message.startsWith(" ")) {
          message = " " + message.trimStart();
        }
        if (!message) {
          message = " ";
        }
        promptInput.value = `@@${name}:${message}`;
        renderPromptMirror();
        requestAnimationFrame(() => {
          promptInput.focus();
          const end = promptInput.value.length;
          promptInput.selectionStart = promptInput.selectionEnd = end;
        });
      }

      function updateMasterSuggestions() {
        if (!masterMode || !promptInput) return;
        const row = promptInput.closest(".prompt-row");
        if (!row) return;
        const suggest = row.querySelector(".master-suggest");
        if (!suggest) return;
        const state = getMasterSuggestionState(promptInput.value || "");
        if (!state || !state.partial) {
          suggest.classList.remove("open");
          suggest.innerHTML = "";
          return;
        }
        const list = getSessionNameList();
        const matches = list.filter((name) => name.toLowerCase().startsWith(state.partial.toLowerCase()));
        if (!matches.length) {
          suggest.classList.remove("open");
          suggest.innerHTML = "";
          return;
        }
        suggest.innerHTML = matches.slice(0, 8).map((name) => {
          return `<button type="button" data-suggest="${escapeHtml(name)}">@@${escapeHtml(name)}</button>`;
        }).join("");
        suggest.classList.add("open");
      }

      if (form) {
        form.addEventListener("submit", async (e) => {
          e.preventDefault();
          const prompt = document.getElementById("prompt").value.trim();
          if (!prompt) return;
          if (masterMode) {
            const parsed = parseMasterInput(prompt);
            if (!parsed) {
              alert("Use @@session-name: message (or @@session message).");
              return;
            }
            const orch = getOrchestratorByName(parsed.name);
            const orchCommand = orch ? parseOrchestratorCommand(parsed.message) : null;
            const shouldRouteToOrch = orch && orchCommand;
            if (shouldRouteToOrch) {
              addMessage(`@@${parsed.name}: ${parsed.message}`, "user");
              promptInput.value = "";
              renderPromptMirror();
              await handleOrchestratorCommand(orch, orchCommand);
              return;
            }
            addMessage(`@@${parsed.name}: ${parsed.message}`, "user");
            promptInput.value = "";
            renderPromptMirror();
            const payload = {
              session_name: parsed.name,
              prompt: parsed.message,
              provider: null,
            };
            setWorking(true, "Thinking...");
            await streamResponse(payload);
            return;
          }

          const sessionName = document.getElementById("session_name").value.trim();
          const forceNew = document.getElementById("force_new").checked;
          if (!sessionName) return;

          addMessage(prompt, "user");
          promptInput.value = "";

          const provider = providerSelect ? providerSelect.value : "codex";
          const payload = {
            session_name: sessionName,
            prompt,
            provider,
          };
          if (forceNew) {
            payload.session_id = null;
          }

          setWorking(true, "Thinking...");
          await streamResponse(payload);
          if (forceNew) {
            document.getElementById("force_new").checked = false;
            statusLine.textContent = "";
          }
        });

        if (promptInput) {
          promptInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              form.requestSubmit();
              return;
            }
            if (masterMode && e.key === "Tab") {
              const next = autocompleteSessionName(promptInput.value);
              if (next) {
                e.preventDefault();
                promptInput.value = next;
                renderPromptMirror();
                // Move caret to end after autocomplete
                  requestAnimationFrame(() => {
                    promptInput.focus();
                    promptInput.selectionStart = promptInput.selectionEnd = promptInput.value.length;
                  });
              }
            }
            if (masterMode && e.key === "Backspace") {
              const range = getMasterPrefixRange(promptInput.value);
              if (range) {
                const start = promptInput.selectionStart || 0;
                const end = promptInput.selectionEnd || 0;
                if (start === end && start <= range.end) {
                  e.preventDefault();
                  const rest = promptInput.value.slice(range.end).trimStart();
                  promptInput.value = rest;
                  renderPromptMirror();
                  requestAnimationFrame(() => {
                    promptInput.selectionStart = promptInput.selectionEnd = 0;
                  });
                }
              }
            }
          });
          promptInput.addEventListener("input", () => {
            if (masterMode) {
              renderPromptMirror();
              updateMasterSuggestions();
            }
          });
          promptInput.addEventListener("focus", () => {
            if (masterMode) updateMasterSuggestions();
          });
        }
      }

      document.addEventListener("click", (e) => {
        if (!masterMode || !promptInput) return;
        const row = promptInput.closest(".prompt-row");
        const suggest = row ? row.querySelector(".master-suggest") : null;
        if (!suggest) return;
        const btn = e.target.closest("[data-suggest]");
        if (btn) {
          e.preventDefault();
          e.stopPropagation();
          const name = btn.getAttribute("data-suggest") || "";
          if (name) applyMasterSuggestion(name);
          suggest.classList.remove("open");
          return;
        }
        if (row && !row.contains(e.target)) {
          suggest.classList.remove("open");
        }
      });

      document.addEventListener("pointerdown", (e) => {
        if (!masterMode || !promptInput) return;
        const row = promptInput.closest(".prompt-row");
        const suggest = row ? row.querySelector(".master-suggest") : null;
        if (!suggest) return;
        const btn = e.target.closest("[data-suggest]");
        if (btn) {
          e.preventDefault();
          e.stopPropagation();
          const name = btn.getAttribute("data-suggest") || "";
          if (name) applyMasterSuggestion(name);
          suggest.classList.remove("open");
        }
      }, { capture: true });

      function wireSessionCards() {
        document.querySelectorAll(".session-card").forEach((card) => {
          card.addEventListener("click", (e) => {
            // Check if clicking on menu button
            if (e.target.closest(".session-menu")) {
              e.preventDefault();
              e.stopPropagation();
              return;
            }
            
            // Prevent default navigation - handle it client-side
            e.preventDefault();
            e.stopPropagation();
            
            const href = card.getAttribute("href") || "";
            const name = href.replace("/chat/", "");
            
            // If already on this session, do nothing
            if (decodeURIComponent(name) === selectedSession) {
              return;
            }
            
            // Show loading state
            card.style.opacity = "0.5";
            card.style.pointerEvents = "none";
            
            // Navigate to the session
            storeNavScroll();
            window.location.href = href;
          });
        });
      }

      function wireDeleteButtons() {
        document.querySelectorAll("[data-delete]").forEach((btn) => {
          btn.addEventListener("click", async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = btn.getAttribute("data-delete");
            if (!name) return;
            if (!confirm(`Delete session "${name}"?`)) return;
            const resp = await fetch(`/sessions/${encodeURIComponent(name)}`, { method: "DELETE" });
            if (!resp.ok) {
              const data = await resp.json().catch(() => ({}));
              appendTool((data.error || "Unable to delete session") + "\n");
              return;
            }
            const item = document.querySelector(`li[data-session-name="${CSS.escape(name)}"]`);
            if (item) item.remove();
            if (selectedSession === name) {
              window.location.href = "/chat";
              return;
            }
            await refreshSessionStatus();
          });
        });
      }

      async function setSessionProvider(name, provider) {
        if (!name) return;
        const resp = await fetch(`/sessions/${encodeURIComponent(name)}/provider`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ provider }),
        });
        if (!resp.ok) {
          const data = await resp.json().catch(() => ({}));
          appendTool((data.error || "Unable to change model") + "\n");
          return;
        }
        updateSessionProvider(name, provider);
        if (selectedSession === name && providerSelect) {
          providerSelect.value = provider;
        }
      }

      function getModelFlyout() {
        let flyout = document.getElementById("modelFlyout");
        if (flyout) return flyout;
        flyout = document.createElement("div");
        flyout.id = "modelFlyout";
        flyout.className = "model-flyout";
        flyout.innerHTML = `
          <button class="menu-item" data-flyout-model="codex">
            codex${providerModels.codex ? ` <span class="model-hint">(${providerModels.codex})</span>` : ''}
          </button>
          <button class="menu-item" data-flyout-model="copilot">
            copilot${providerModels.copilot ? ` <span class="model-hint">(${providerModels.copilot})</span>` : ''}
          </button>
          <button class="menu-item" data-flyout-model="gemini">
            gemini${providerModels.gemini ? ` <span class="model-hint">(${providerModels.gemini})</span>` : ''}
          </button>
          <button class="menu-item" data-flyout-model="claude">
            claude${providerModels.claude ? ` <span class="model-hint">(${providerModels.claude})</span>` : ''}
          </button>
        `;
        document.body.appendChild(flyout);
        return flyout;
      }

      function wireShowIdsButtons() {
        document.querySelectorAll("[data-show-ids]").forEach((btn) => {
          btn.addEventListener("click", async (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Close the menu panel
            const menuPanel = btn.closest(".menu-panel");
            if (menuPanel) {
              menuPanel.classList.remove("open");
            }
            
            const name = btn.getAttribute("data-show-ids");
            if (!name) return;
            try {
              const resp = await fetch("/sessions");
              if (!resp.ok) throw new Error("Unable to load sessions");
              const data = await resp.json();
              const record = data && data.sessions ? data.sessions[name] : null;
              const provider = record && record.provider ? record.provider : "codex";
              const sessionIds = record && record.session_ids ? record.session_ids : {};
              if (idsBody) {
                idsBody.innerHTML = "";
                const header = document.createElement("div");
                header.className = "muted";
                header.style.marginBottom = "8px";
                header.textContent = `provider: ${provider}`;
                idsBody.appendChild(header);
                Object.entries(sessionIds).forEach(([key, val]) => {
                  const row = document.createElement("div");
                  row.className = "id-row";
                  row.innerHTML = `<code>${key}: ${val || "none"}</code>`;
                  const copy = document.createElement("button");
                  copy.className = "copy-btn";
                  copy.innerHTML = "⧉";
                  copy.title = "Copy";
                  copy.addEventListener("click", async () => {
                    try {
                      await navigator.clipboard.writeText(val || "");
                      copy.innerHTML = "✓";
                      setTimeout(() => (copy.innerHTML = "⧉"), 1200);
                    } catch (err) {
                      appendTool("Unable to copy to clipboard.\n");
                    }
                  });
                  row.appendChild(copy);
                  idsBody.appendChild(row);
                });
                if (!Object.keys(sessionIds).length) {
                  const empty = document.createElement("div");
                  empty.className = "muted";
                  empty.textContent = "No session ids yet.";
                  idsBody.appendChild(empty);
                }
                if (idsOverlay) idsOverlay.classList.add("open");
                if (idsModal) idsModal.classList.add("open");
              }
            } catch (err) {
              appendTool("Unable to load session IDs.\n");
            }
          });
        });
      }

      function wireRenameButtons() {
        document.querySelectorAll("[data-rename]").forEach((btn) => {
          btn.addEventListener("click", async (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = btn.getAttribute("data-rename");
            if (!name) return;
            const next = prompt("New session name", name);
            if (!next) return;
            const trimmed = next.trim();
            if (!trimmed || trimmed === name) return;
            const resp = await fetch(`/sessions/${encodeURIComponent(name)}/rename`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ new_name: trimmed }),
            });
            if (!resp.ok) {
              const data = await resp.json().catch(() => ({}));
              appendTool((data.error || "Unable to rename session") + "\n");
              return;
            }
            await refreshSessionStatus();
            if (selectedSession === name) {
              window.location.href = `/chat/${encodeURIComponent(trimmed)}`;
            }
          });
        });
      }

      function wireMenus() {
        document.querySelectorAll(".session-menu").forEach((menu) => {
          const btn = menu.querySelector(".menu-btn");
          const panel = menu.querySelector(".menu-panel");
          if (!btn || !panel) return;
          btn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            const wasOpen = panel.classList.contains("open");
            document.querySelectorAll(".menu-panel.open").forEach((open) => {
              if (open !== panel) open.classList.remove("open");
            });
            if (wasOpen) {
              panel.classList.remove("open");
              return;
            }
            panel.classList.add("open");
            const rect = btn.getBoundingClientRect();
            const panelWidth = panel.offsetWidth || 0;
            let left = rect.left;
            const maxLeft = Math.max(8, window.innerWidth - panelWidth - 8);
            if (left > maxLeft) left = maxLeft;
            if (left < 8) left = 8;
            panel.style.top = `${rect.bottom + 4}px`;
            panel.style.left = `${left}px`;
          });
          const modelBtn = panel.querySelector(".menu-item.has-submenu");
          if (modelBtn) {
            let hoverTimer;
            modelBtn.addEventListener("click", (e) => {
              e.preventDefault();
              e.stopPropagation();
              const flyout = getModelFlyout();
              const rect = modelBtn.getBoundingClientRect();
              flyout.style.top = `${rect.top}px`;
              flyout.style.left = `${rect.right + 8}px`;
              flyout.dataset.sessionName = modelBtn.getAttribute("data-model-menu") || "";
              flyout.classList.toggle("open");
            });
            modelBtn.addEventListener("mouseenter", () => {
              const flyout = getModelFlyout();
              const rect = modelBtn.getBoundingClientRect();
              flyout.style.top = `${rect.top}px`;
              flyout.style.left = `${rect.right + 8}px`;
              flyout.dataset.sessionName = modelBtn.getAttribute("data-model-menu") || "";
              clearTimeout(hoverTimer);
              hoverTimer = setTimeout(() => flyout.classList.add("open"), 120);
            });
            modelBtn.addEventListener("mouseleave", () => {
              const flyout = getModelFlyout();
              clearTimeout(hoverTimer);
              hoverTimer = setTimeout(() => {
                if (!flyout.matches(":hover")) {
                  flyout.classList.remove("open");
                }
              }, 200);
            });
          }
          btn.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
          });
          panel.addEventListener("click", (e) => {
            e.stopPropagation();
          });
          panel.addEventListener("mousedown", (e) => {
            e.stopPropagation();
          });
        });
        document.addEventListener("click", () => {
          document.querySelectorAll(".menu-panel.open").forEach((open) => open.classList.remove("open"));
          const flyout = document.getElementById("modelFlyout");
          if (flyout) flyout.classList.remove("open");
        });
        window.addEventListener("scroll", () => {
          document.querySelectorAll(".menu-panel.open").forEach((open) => open.classList.remove("open"));
          const flyout = document.getElementById("modelFlyout");
          if (flyout) flyout.classList.remove("open");
        }, true);
        window.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            document.querySelectorAll(".menu-panel.open").forEach((open) => open.classList.remove("open"));
            const flyout = document.getElementById("modelFlyout");
            if (flyout) flyout.classList.remove("open");
          }
        });
        const flyout = getModelFlyout();
        flyout.addEventListener("mouseenter", () => {
          flyout.classList.add("open");
        });
        flyout.addEventListener("mouseleave", () => {
          flyout.classList.remove("open");
        });
        flyout.addEventListener("click", async (e) => {
          const target = e.target.closest("[data-flyout-model]");
          if (!target) return;
          e.preventDefault();
          e.stopPropagation();
          const next = target.getAttribute("data-flyout-model");
          const name = flyout.dataset.sessionName;
          if (!name || !next) return;
          await setSessionProvider(name, next);
          flyout.classList.remove("open");
        });
      }

      wireSessionCards();
      wireDeleteButtons();
      wireRenameButtons();
      wireShowIdsButtons();
      wireMenus();

      // Add Session Modal
      const addSessionBtn = document.getElementById("addSessionBtn");
      const addSessionOverlay = document.getElementById("addSessionOverlay");
      const addSessionModal = document.getElementById("addSessionModal");
      const addSessionForm = document.getElementById("addSessionForm");
      const addSessionCloseBtn = document.getElementById("addSessionCloseBtn");
      const addSessionCancelBtn = document.getElementById("addSessionCancelBtn");
      const newSessionName = document.getElementById("newSessionName");
      const newSessionModel = document.getElementById("newSessionModel");
      const newSessionId = document.getElementById("newSessionId");
      const newSessionWorkdir = document.getElementById("newSessionWorkdir");
      const newSessionPickWorkdir = document.getElementById("newSessionPickWorkdir");
      const newSessionClearWorkdir = document.getElementById("newSessionClearWorkdir");
      let newSessionWorkdirValue = "";

      function openAddSessionModal() {
        newSessionName.value = "";
        newSessionModel.value = "codex";
        if (newSessionId) newSessionId.value = "";
        newSessionWorkdirValue = "";
        newSessionWorkdir.textContent = "Not set";
        addSessionOverlay.classList.add("open");
        addSessionModal.classList.add("open");
        setTimeout(() => newSessionName.focus(), 50);
      }

      function closeAddSessionModal() {
        addSessionOverlay.classList.remove("open");
        addSessionModal.classList.remove("open");
      }

      // Wire up empty state button
      const emptyStateAddBtn = document.getElementById("emptyStateAddBtn");
      if (emptyStateAddBtn) {
        emptyStateAddBtn.addEventListener("click", openAddSessionModal);
      }

      if (addSessionBtn) {
        addSessionBtn.addEventListener("click", openAddSessionModal);
      }
      if (addSessionCloseBtn) {
        addSessionCloseBtn.addEventListener("click", closeAddSessionModal);
      }
      if (addSessionCancelBtn) {
        addSessionCancelBtn.addEventListener("click", closeAddSessionModal);
      }
      if (addSessionOverlay) {
        addSessionOverlay.addEventListener("click", closeAddSessionModal);
      }

      if (newSessionPickWorkdir) {
        newSessionPickWorkdir.addEventListener("click", async () => {
          try {
            const resp = await fetch("/pick-workdir", { method: "POST" });
            if (resp.ok) {
              const data = await resp.json();
              if (data && data.path) {
                newSessionWorkdirValue = data.path;
                newSessionWorkdir.textContent = data.path;
                // Enable the init checkbox when workdir is set
                const initCheckbox = document.getElementById("newSessionRunInit");
                if (initCheckbox) initCheckbox.disabled = false;
              } else if (data && data.error) {
                // Show manual input if picker fails (e.g., tkinter not available)
                alert(data.error + "\n\nYou can type the path manually instead.");
                const manualInput = document.getElementById("newSessionWorkdirManual");
                if (manualInput) manualInput.style.display = "block";
              }
            }
          } catch (err) {
            console.error("Failed to pick workdir:", err);
          }
        });
      }
      
      // Handle manual workdir input
      const newSessionWorkdirManual = document.getElementById("newSessionWorkdirManual");
      if (newSessionWorkdirManual) {
        newSessionWorkdirManual.addEventListener("input", (e) => {
          const path = e.target.value.trim();
          if (path) {
            newSessionWorkdirValue = path;
            newSessionWorkdir.textContent = path;
            // Enable the init checkbox when workdir is set
            const initCheckbox = document.getElementById("newSessionRunInit");
            if (initCheckbox) initCheckbox.disabled = false;
          } else {
            newSessionWorkdirValue = "";
            newSessionWorkdir.textContent = "Not set";
            // Disable and uncheck the init checkbox when workdir is cleared
            const initCheckbox = document.getElementById("newSessionRunInit");
            if (initCheckbox) {
              initCheckbox.disabled = true;
              initCheckbox.checked = false;
            }
          }
        });
      }

      if (newSessionClearWorkdir) {
        newSessionClearWorkdir.addEventListener("click", () => {
          newSessionWorkdirValue = "";
          newSessionWorkdir.textContent = "Not set";
          // Clear manual input too
          const manualInput = document.getElementById("newSessionWorkdirManual");
          if (manualInput) manualInput.value = "";
          // Disable and uncheck the init checkbox when workdir is cleared
          const initCheckbox = document.getElementById("newSessionRunInit");
          if (initCheckbox) {
            initCheckbox.disabled = true;
            initCheckbox.checked = false;
          }
        });
      }

      if (addSessionForm) {
        addSessionForm.addEventListener("submit", async (e) => {
          e.preventDefault();
          const name = newSessionName.value.trim();
          if (!name) return;
          const provider = newSessionModel.value;
          const runInit = document.getElementById("newSessionRunInit").checked;
          try {
            const resp = await fetch("/sessions", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                name,
                provider,
                session_id: newSessionId ? newSessionId.value.trim() : "",
                workdir: newSessionWorkdirValue || undefined,
                run_init: runInit
              })
            });
            if (!resp.ok) {
              const data = await resp.json().catch(() => ({}));
              alert(data.error || "Failed to create session");
              return;
            }
            closeAddSessionModal();
            // Redirect with init flag if applicable
            const redirectUrl = runInit 
              ? `/chat/${encodeURIComponent(name)}?initializing=true`
              : `/chat/${encodeURIComponent(name)}`;
            window.location.href = redirectUrl;
          } catch (err) {
            console.error("Failed to create session:", err);
            alert("Failed to create session");
          }
        });
      }

      // Add Orchestrator Modal
      function openAddOrchModal() {
        if (orchNameInput) orchNameInput.value = "";
        if (orchProviderSelect) orchProviderSelect.value = "codex";
        if (orchGoalInput) orchGoalInput.value = "";
        if (orchEnabledInput) orchEnabledInput.checked = true;
        if (orchSessionList) {
          orchSessionList.querySelectorAll("input[type='checkbox']").forEach((cb) => {
            cb.checked = false;
          });
        }
        if (addOrchOverlay) addOrchOverlay.classList.add("open");
        if (addOrchModal) addOrchModal.classList.add("open");
        setTimeout(() => orchNameInput && orchNameInput.focus(), 50);
      }

      function closeAddOrchModal() {
        if (addOrchOverlay) addOrchOverlay.classList.remove("open");
        if (addOrchModal) addOrchModal.classList.remove("open");
      }

      if (addOrchBtn) {
        addOrchBtn.addEventListener("click", openAddOrchModal);
      }
      if (addOrchCloseBtn) {
        addOrchCloseBtn.addEventListener("click", closeAddOrchModal);
      }
      if (addOrchCancelBtn) {
        addOrchCancelBtn.addEventListener("click", closeAddOrchModal);
      }
      if (addOrchOverlay) {
        addOrchOverlay.addEventListener("click", closeAddOrchModal);
      }

      if (addOrchForm) {
        addOrchForm.addEventListener("submit", async (e) => {
          e.preventDefault();
          const name = orchNameInput ? orchNameInput.value.trim() : "";
          if (!name) return;
          const provider = orchProviderSelect ? orchProviderSelect.value : "codex";
          const goal = orchGoalInput ? orchGoalInput.value.trim() : "";
          const managed = orchSessionList
            ? Array.from(orchSessionList.querySelectorAll("input[type='checkbox']:checked")).map((cb) => cb.value)
            : [];
          const enabled = orchEnabledInput ? orchEnabledInput.checked : true;
          try {
            const resp = await fetch("/orchestrators", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ name, provider, goal, managed_sessions: managed, enabled }),
            });
            if (!resp.ok) {
              const data = await resp.json().catch(() => ({}));
              alert(data.error || "Failed to create orchestrator");
              return;
            }
            closeAddOrchModal();
            await refreshOrchestrators();
          } catch (err) {
            console.error("Failed to create orchestrator:", err);
            alert("Failed to create orchestrator");
          }
        });
      }

      // Task Modal Form Submit
      if (addTaskForm) {
        addTaskForm.addEventListener("submit", async (e) => {
          e.preventDefault();

          const name = modalTaskNameInput ? modalTaskNameInput.value.trim() : "";
          const prompt = modalTaskPromptInput ? modalTaskPromptInput.value.trim() : "";

          if (!name || !prompt) {
            alert("Task name and prompt are required.");
            return;
          }

          const scheduleType = modalTaskScheduleType ? modalTaskScheduleType.value : "manual";
          const schedule = { type: scheduleType };

          if (scheduleType === "interval") {
            schedule.minutes = parseInt(modalTaskIntervalInput.value || "60", 10);
          } else if (scheduleType === "daily" || scheduleType === "weekly" || scheduleType === "once") {
            schedule.time = modalTaskTimeInput.value || "";
          }

          if (scheduleType === "weekly") {
            const days = [];
            document.querySelectorAll(".modal-task-day").forEach((el) => {
              if (el.checked) days.push(el.value);
            });
            schedule.days = days;
          }

          const body = {
            name,
            prompt,
            provider: modalTaskProviderSelect ? modalTaskProviderSelect.value : "codex",
            schedule,
            enabled: true,
          };

          const resp = await fetch("/tasks", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });

          if (!resp.ok) {
            const data = await resp.json().catch(() => ({}));
            alert(data.error || "Failed to create task");
            return;
          }

          // Close modal and reset form on success
          closeAddTaskModal();

          // Task list will update via SSE
        });
      }

      function renderTasks(tasks) {
        if (!tasksList) return;
        const sessionsPanel = document.querySelector(".sessions");
        const prevScroll = sessionsPanel ? sessionsPanel.scrollTop : 0;
        if (!tasks || !tasks.length) {
          tasksList.innerHTML = '<li class="muted">No tasks yet.</li>';
          taskCache = {};
          return;
        }
        taskCache = {};
        const selectedTaskId = "{{ selected_task.id if selected_task else '' }}";
        const orderedTasks = [...tasks].sort((a, b) => {
          const aLast = a.last_run || "";
          const bLast = b.last_run || "";
          if (aLast !== bLast) {
            return bLast.localeCompare(aLast);
          }
          return (a.name || "").localeCompare(b.name || "");
        });
        tasksList.innerHTML = orderedTasks
          .map((task) => {
            taskCache[task.id] = task;
            const status = task.last_status || "idle";
            const schedule = task.schedule_summary || "Manual";
            const lastRun = task.last_run ? `Last run: ${task.last_run}` : "Never run";
            const nextRun = task.next_run ? `Next: ${task.next_run}` : "";
            const isActive = selectedTaskId === task.id ? "active" : "";
            return `
              <li class="${isActive}">
                <a href="/task/${task.id}" class="task-card ${isActive}" data-task-id="${task.id}">
                  <div class="task-meta">
                    <div>
                      <strong>${task.name}</strong>
                      <div class="task-detail">${schedule} · <span class="provider-tag" data-provider>${task.provider}</span></div>
                    </div>
                    <div class="task-actions">
                      <span class="status-dot ${status === 'running' ? 'running' : status === 'error' ? 'error' : ''}" 
                            aria-label="${status === 'running' ? 'Running' : status === 'error' ? 'Error' : 'Idle'}" 
                            title="${status === 'running' ? 'Running' : status === 'error' ? 'Error' : 'Idle'}"></span>
                      <div class="task-menu" data-task-menu="${task.id}">
                        <button class="menu-btn" type="button" aria-label="Task menu">⋮</button>
                      </div>
                    </div>
                  </div>
                  <div class="task-detail">${lastRun} ${nextRun ? nextRun : ''}</div>
                  ${status === "error" && task.last_error ? `<div class="task-detail">Error: ${task.last_error}</div>` : ""}
                </a>
              </li>
            `;
          })
          .join("");
        wireTaskButtons();
        wireTaskMenus();
        applyNavFilter();
        if (sessionsPanel) {
          sessionsPanel.scrollTop = prevScroll;
        }
        applyPendingNavScroll();
      }

      function renderOrchestrators(orchestrators) {
        if (!orchestratorsList) return;
        const sessionsPanel = document.querySelector(".sessions");
        const prevScroll = sessionsPanel ? sessionsPanel.scrollTop : 0;
        if (!orchestrators || !orchestrators.length) {
          orchestratorsList.innerHTML = '<li class="muted">No orchestrators yet.</li>';
          orchCache = {};
          return;
        }
        orchCache = {};
        const ordered = [...orchestrators].sort((a, b) => {
          const aCreated = a.created_at || "";
          const bCreated = b.created_at || "";
          if (aCreated !== bCreated) {
            return bCreated.localeCompare(aCreated);
          }
          return (a.name || "").localeCompare(b.name || "");
        });
        orchestratorsList.innerHTML = ordered
          .map((orch) => {
            orchCache[orch.id] = orch;
            const enabled = !!orch.enabled;
            const statusText = enabled ? "Enabled" : "Paused";
            const managed = Array.isArray(orch.managed_sessions) ? orch.managed_sessions.length : 0;
            const managedText = managed === 1 ? "1 session" : `${managed} sessions`;
            const goalText = orch.goal ? escapeHtml(orch.goal) : "No goal set";
            const lastAt = orch.last_decision_at ? `Last decision: ${orch.last_decision_at}` : "No decisions yet";
            const lastAction = orch.last_action ? ` (${orch.last_action})` : "";
            const lastQuestion = orch.last_question ? ` · ${escapeHtml(orch.last_question)}` : "";
            const activeClass = selectedOrchId && selectedOrchId === orch.id ? "active" : "";
            return `
              <li class="${activeClass}">
                <div class="orchestrator-card ${enabled ? "active" : ""}" data-orch-id="${orch.id}">
                  <div class="orchestrator-meta">
                    <div>
                      <strong>${escapeHtml(orch.name)}</strong>
                      <div class="orchestrator-detail">${managedText} · <span class="provider-tag" data-provider>${orch.provider}</span></div>
                    </div>
                    <div class="orchestrator-actions">
                      <span class="status-dot ${enabled ? "running" : ""}" aria-label="${statusText}" title="${statusText}"></span>
                      <button class="orch-toggle-btn" data-orch-action="toggle">${enabled ? "Pause" : "Start"}</button>
                      <button class="orch-delete-btn" data-orch-action="delete">Delete</button>
                    </div>
                  </div>
                  <div class="orchestrator-detail">${goalText}</div>
                  <div class="orchestrator-detail">${lastAt}${lastAction}${lastQuestion}</div>
                </div>
              </li>
            `;
          })
          .join("");
        applyNavFilter();
        if (sessionsPanel) {
          sessionsPanel.scrollTop = prevScroll;
        }
        applyPendingNavScroll();
      }

      async function refreshOrchestrators() {
        try {
          const resp = await fetch("/orchestrators");
          if (resp.ok) {
            const data = await resp.json();
            renderOrchestrators(data.orchestrators || []);
          }
        } catch (err) {
          // ignore
        }
      }

      function wireTaskButtons() {
        // Task actions are handled via the shared flyout menu.
      }

      if (orchestratorsList) {
        orchestratorsList.addEventListener("click", async (e) => {
          const btn = e.target.closest("[data-orch-action]");
          if (!btn) return;
          e.preventDefault();
          e.stopPropagation();
          const card = btn.closest("[data-orch-id]");
          const orchId = card ? card.getAttribute("data-orch-id") : "";
          if (!orchId) return;
          const orch = orchCache[orchId];
          const enabled = orch ? !!orch.enabled : false;
          const action = btn.getAttribute("data-orch-action");
          if (action === "delete") {
            const ok = confirm("Delete this orchestrator?");
            if (!ok) return;
            try {
              await fetch(`/orchestrators/${encodeURIComponent(orchId)}`, { method: "DELETE" });
            } catch (err) {
              console.error("Failed to delete orchestrator:", err);
            }
            refreshOrchestrators();
            if (selectedOrchId === orchId) {
              window.location.href = "/chat";
            }
            return;
          }
          const endpoint = enabled ? `/orchestrators/${encodeURIComponent(orchId)}/pause` : `/orchestrators/${encodeURIComponent(orchId)}/start`;
          try {
            await fetch(endpoint, { method: "POST" });
          } catch (err) {
            console.error("Failed to toggle orchestrator:", err);
          }
          refreshOrchestrators();
        });
        orchestratorsList.addEventListener("click", (e) => {
          const btn = e.target.closest("[data-orch-action]");
          if (btn) return;
          const card = e.target.closest("[data-orch-id]");
          if (!card) return;
          const orchId = card.getAttribute("data-orch-id");
          if (!orchId) return;
          storeNavScroll();
          window.location.href = `/orchestrator/${encodeURIComponent(orchId)}`;
        });
      }

      function wireTaskStream() {
        if (!window.EventSource) {
          fetch("/tasks")
            .then((resp) => resp.json())
            .then((data) => {
              renderTasks(data.tasks || []);
              refreshTaskDetailIfNeeded(data.tasks || []);
            })
            .catch(() => {});
          return;
        }
        const source = new EventSource("/tasks/stream");
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
          source.close();
        });
        
        source.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data || "{}");
            renderTasks(data.tasks || []);
            refreshTaskDetailIfNeeded(data.tasks || []);
          } catch (err) {
            // ignore
          }
        };
        source.onerror = () => {
          source.close();
        };
      }

      // Start task stream for live status updates
      // Always run to show task status, even when viewing a specific task
      const viewMode = "{{ view_mode if view_mode else '' }}";
      const selectedTaskId = "{{ selected_task.id if selected_task else '' }}";
      let taskDetailLastSig = null;
      let taskDetailStream = null;

      async function refreshTaskDetailIfNeeded(tasks) {
        if (!selectedTaskId) return;
        const task = (tasks || []).find((t) => t.id === selectedTaskId);
        if (!task) return;
        const sig = `${task.last_run || ""}|${task.last_status || ""}|${(task.last_output || "").length}|${task.last_error || ""}`;
        if (sig === taskDetailLastSig) return;
        taskDetailLastSig = sig;
        try {
          const resp = await fetch(`/tasks/${encodeURIComponent(selectedTaskId)}`);
          if (!resp.ok) return;
          const data = await resp.json();
          const fullTask = data.task || {};
          updateTaskOutputSections(fullTask);
        } catch (err) {
          // ignore
        }
      }

      function updateTaskOutputSections(task) {
        const detailView = document.getElementById("taskDetailView");
        if (!detailView) return;
        const outputText = (task.output_history_text || task.last_output || "").trim();
        const rawText = (task.raw_output_history_text || task.last_output_raw || "").trim();

        let outputSection = document.getElementById("taskOutputSection");
        if (!outputSection) {
          outputSection = document.createElement("div");
          outputSection.className = "task-output-section";
          outputSection.id = "taskOutputSection";
          const h3 = document.createElement("h3");
          h3.textContent = "Output";
          const pre = document.createElement("pre");
          pre.className = "task-output-content";
          pre.id = "taskOutputContent";
          outputSection.appendChild(h3);
          outputSection.appendChild(pre);
          detailView.appendChild(outputSection);
        }
        const outputContent = document.getElementById("taskOutputContent");
        if (outputContent) outputContent.textContent = outputText;
        outputSection.style.display = outputText ? "" : "none";

        let rawSection = document.getElementById("taskRawOutputSection");
        if (!rawSection) {
          rawSection = document.createElement("details");
          rawSection.className = "task-output-section";
          rawSection.id = "taskRawOutputSection";
          const summary = document.createElement("summary");
          summary.textContent = "Raw output";
          const pre = document.createElement("pre");
          pre.className = "task-output-content";
          pre.id = "taskRawOutputContent";
          rawSection.appendChild(summary);
          rawSection.appendChild(pre);
          detailView.appendChild(rawSection);
        }
        const rawContent = document.getElementById("taskRawOutputContent");
        if (rawContent) rawContent.textContent = rawText;
        rawSection.style.display = rawText ? "" : "none";
      }

      function appendTaskLiveOutput(text, kind) {
        if (!text) return;
        const detailView = document.getElementById("taskDetailView");
        if (!detailView) return;
        let outputSection = document.getElementById("taskOutputSection");
        if (!outputSection) {
          updateTaskOutputSections({ output_history_text: "", raw_output_history_text: "" });
          outputSection = document.getElementById("taskOutputSection");
        }
        const outputContent = document.getElementById("taskOutputContent");
        if (!outputContent) return;
        const prefix = kind === "stderr" ? "[stderr] " : "";
        outputContent.textContent = `${outputContent.textContent}${outputContent.textContent ? "\n" : ""}${prefix}${text}`;
      }

      function wireTaskDetailStream() {
        if (!selectedTaskId || !window.EventSource) return;
        if (taskDetailStream) return;
        taskDetailStream = new EventSource(`/tasks/${encodeURIComponent(selectedTaskId)}/stream`);
        taskDetailStream.addEventListener("output", (event) => {
          try {
            const data = JSON.parse(event.data || "{}");
            appendTaskLiveOutput(data.text || "", "stdout");
          } catch (err) {
            // ignore
          }
        });
        taskDetailStream.addEventListener("stderr", (event) => {
          try {
            const data = JSON.parse(event.data || "{}");
            appendTaskLiveOutput(data.text || "", "stderr");
          } catch (err) {
            // ignore
          }
        });
        taskDetailStream.addEventListener("done", (event) => {
          taskDetailStream.close();
          taskDetailStream = null;
        });
        window.addEventListener("beforeunload", () => {
          if (taskDetailStream) taskDetailStream.close();
        });
      }
      wireTaskStream();
      renderOrchestrators(initialOrchestrators || []);
      refreshOrchestrators();
      setInterval(refreshOrchestrators, 4000);

      // Task detail view handlers
      if (document.getElementById("taskEditForm")) {
        const taskEditForm = document.getElementById("taskEditForm");
        const runTaskBtn = document.getElementById("runTaskBtn");
        const reauthGmailBtn = document.getElementById("reauthGmailBtn");
        const deleteTaskBtn = document.getElementById("deleteTaskBtn");
        const cancelTaskEdit = document.getElementById("cancelTaskEdit");
        const taskEditScheduleType = document.getElementById("taskScheduleType");
        const scheduleOnceFields = document.getElementById("scheduleOnceFields");
        const scheduleIntervalFields = document.getElementById("scheduleIntervalFields");
        const scheduleDailyFields = document.getElementById("scheduleDailyFields");
        const scheduleWeeklyFields = document.getElementById("scheduleWeeklyFields");
        const scheduleMonthlyFields = document.getElementById("scheduleMonthlyFields");
        const taskPickWorkdir = document.getElementById("taskPickWorkdir");
        wireTaskDetailStream();

        function updateScheduleFieldsVisibility() {
          if (!taskEditScheduleType) return;
          const type = taskEditScheduleType.value;
          console.log('Schedule type:', type);
          // Hide all schedule fields
          [scheduleOnceFields, scheduleIntervalFields, scheduleDailyFields, scheduleWeeklyFields, scheduleMonthlyFields].forEach(el => {
            if (el) {
              el.classList.remove("active");
              console.log('Hiding', el.id);
            }
          });
          // Show relevant field
          if (type === "once" && scheduleOnceFields) {
            scheduleOnceFields.classList.add("active");
            console.log('Showing once fields');
          }
          if (type === "interval" && scheduleIntervalFields) {
            scheduleIntervalFields.classList.add("active");
            console.log('Showing interval fields');
          }
          if (type === "daily" && scheduleDailyFields) {
            scheduleDailyFields.classList.add("active");
            console.log('Showing daily fields');
          }
          if (type === "weekly" && scheduleWeeklyFields) {
            scheduleWeeklyFields.classList.add("active");
            console.log('Showing weekly fields');
          }
          if (type === "monthly" && scheduleMonthlyFields) {
            scheduleMonthlyFields.classList.add("active");
            console.log('Showing monthly fields');
          }
        }

        if (taskEditScheduleType) {
          taskEditScheduleType.addEventListener("change", updateScheduleFieldsVisibility);
          // Trigger on page load after DOM is fully ready
          requestAnimationFrame(() => {
            setTimeout(updateScheduleFieldsVisibility, 200);
          });
        }

      if (taskPickWorkdir) {
        taskPickWorkdir.addEventListener("click", async () => {
          try {
            const resp = await fetch("/pick-workdir", { method: "POST" });
            if (resp.ok) {
              const data = await resp.json();
              if (data && data.path) {
                document.getElementById("taskWorkdir").value = data.path;
              }
            }
          } catch (err) {
            console.error("Failed to pick workdir:", err);
          }
        });
      }

      if (taskEditForm) {
        taskEditForm.addEventListener("submit", async (e) => {
          e.preventDefault();
          const taskId = "{{ selected_task.id if selected_task else '' }}";
          if (!taskId) return;

          const scheduleType = document.getElementById("taskScheduleType").value;
          const schedule = { type: scheduleType };
          
          if (scheduleType === "once") {
            schedule.date = document.getElementById("taskScheduleDate").value || "";
            schedule.time = document.getElementById("taskScheduleOnceTime").value || "00:00";
          } else if (scheduleType === "interval") {
            schedule.minutes = parseInt(document.getElementById("taskScheduleMinutes").value || "60", 10);
            schedule.start_date = document.getElementById("taskIntervalStartDate").value || "";
            schedule.start_time = document.getElementById("taskIntervalStartTime").value || "00:00";
          } else if (scheduleType === "daily") {
            schedule.time = document.getElementById("taskScheduleDailyTime").value || "00:00";
            schedule.start_date = document.getElementById("taskDailyStartDate").value || "";
            schedule.recur_days = parseInt(document.getElementById("taskDailyRecur").value || "1", 10);
          } else if (scheduleType === "weekly") {
            schedule.time = document.getElementById("taskScheduleWeeklyTime").value || "00:00";
            schedule.start_date = document.getElementById("taskWeeklyStartDate").value || "";
            schedule.recur_weeks = parseInt(document.getElementById("taskWeeklyRecur").value || "1", 10);
            const days = [];
            document.querySelectorAll('input[name="weekday"]:checked').forEach(el => {
              days.push(el.value);
            });
            schedule.days = days;
          } else if (scheduleType === "monthly") {
            schedule.time = document.getElementById("taskScheduleMonthlyTime").value || "00:00";
            schedule.start_date = document.getElementById("taskMonthlyStartDate").value || "";
            schedule.day = parseInt(document.getElementById("taskScheduleDay").value || "1", 10);
            schedule.recur_months = parseInt(document.getElementById("taskMonthlyRecur").value || "1", 10);
          }

          const body = {
            name: document.getElementById("taskName").value.trim(),
            prompt: document.getElementById("taskCommand").value.trim(),
            provider: document.getElementById("taskProvider").value,
            workdir: document.getElementById("taskWorkdir").value.trim(),
            schedule,
            enabled: document.getElementById("taskEnabled").checked,
          };

          try {
            const resp = await fetch(`/tasks/${taskId}`, {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(body),
            });
            if (resp.ok) {
              window.location.reload();
            } else {
              const data = await resp.json().catch(() => ({}));
              alert(data.error || "Failed to update task");
            }
          } catch (err) {
            console.error("Failed to update task:", err);
            alert("Failed to update task");
          }
        });
      }

      if (runTaskBtn) {
        runTaskBtn.addEventListener("click", async () => {
          const taskId = "{{ selected_task.id if selected_task else '' }}";
          if (!taskId) return;
          try {
            const resp = await fetch(`/tasks/${taskId}/run`, { method: "POST" });
            if (!resp.ok) {
              const data = await resp.json().catch(() => ({}));
              alert(data.error || "Failed to run task");
            }
          } catch (err) {
            console.error("Failed to run task:", err);
            alert("Failed to run task");
          }
        });
      }

      if (reauthGmailBtn) {
        reauthGmailBtn.addEventListener("click", async () => {
          if (!confirm("Fix Gmail auth now? This will re-run Google consent.")) return;
          try {
            const resp = await fetch("/gmail/reauth", { method: "POST" });
            if (!resp.ok) {
              const data = await resp.json().catch(() => ({}));
              alert(data.error || "Failed to start Gmail re-auth");
              return;
            }
            alert("Gmail auth started. Check the terminal for the auth link.");
          } catch (err) {
            alert("Failed to start Gmail re-auth");
          }
        });
      }

      if (deleteTaskBtn) {
        deleteTaskBtn.addEventListener("click", async () => {
          const taskId = "{{ selected_task.id if selected_task else '' }}";
          const taskName = "{{ selected_task.name if selected_task else '' }}";
          if (!taskId) return;
          if (!confirm(`Delete task "${taskName}"?`)) return;
          try {
            const resp = await fetch(`/tasks/${taskId}`, { method: "DELETE" });
            if (resp.ok) {
              window.location.href = "/chat";
            } else {
              const data = await resp.json().catch(() => ({}));
              alert(data.error || "Failed to delete task");
            }
          } catch (err) {
            console.error("Failed to delete task:", err);
            alert("Failed to delete task");
          }
        });
      }

      if (cancelTaskEdit) {
        cancelTaskEdit.addEventListener("click", () => {
          window.location.href = "/chat";
        });
      }
      } // End task detail view block

      function wireTaskMenus() {
        const getFlyout = () => {
          let flyout = document.getElementById("taskFlyout");
          if (flyout) return flyout;
          flyout = document.createElement("div");
          flyout.id = "taskFlyout";
          flyout.className = "task-flyout";
          flyout.innerHTML = `
            <button class="menu-item" data-task-action="run">Run</button>
            <button class="menu-item" data-task-action="edit">Edit</button>
            <button class="menu-item" data-task-action="toggle">Disable</button>
            <button class="menu-item danger" data-task-action="delete">Delete</button>
          `;
          document.body.appendChild(flyout);
          return flyout;
        };

        const positionFlyout = (flyout, btn) => {
          const rect = btn.getBoundingClientRect();
          flyout.style.top = `${rect.bottom + 6}px`;
          flyout.style.left = `${rect.right - flyout.offsetWidth}px`;
        };

        document.querySelectorAll(".task-menu .menu-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            const menu = btn.closest(".task-menu");
            const taskId = menu ? menu.getAttribute("data-task-menu") : "";
            if (!taskId) return;
            const flyout = getFlyout();
            const task = taskCache[taskId];
            if (task) {
              const toggleBtn = flyout.querySelector('[data-task-action="toggle"]');
              if (toggleBtn) {
                toggleBtn.textContent = task.enabled ? "Disable" : "Enable";
              }
            }
            flyout.dataset.taskId = taskId;
            flyout.classList.add("open");
            positionFlyout(flyout, btn);
          });
        });

        const flyout = getFlyout();
        flyout.addEventListener("click", async (e) => {
          const target = e.target.closest("[data-task-action]");
          if (!target) return;
          const action = target.getAttribute("data-task-action");
          const taskId = flyout.dataset.taskId;
          if (!taskId) return;
          if (action === "run") {
            await fetch(`/tasks/${encodeURIComponent(taskId)}/run`, { method: "POST" });
          } else if (action === "edit") {
            const task = taskCache[taskId];
            if (task) {
              editingTaskId = taskId;
              taskForm.classList.add("active");
              taskNameInput.value = task.name || "";
              taskPromptInput.value = task.prompt || "";
              if (taskProviderSelect) taskProviderSelect.value = task.provider || "codex";
              if (taskScheduleType) taskScheduleType.value = (task.schedule && task.schedule.type) || "manual";
              if (taskIntervalInput && task.schedule && task.schedule.minutes) {
                taskIntervalInput.value = task.schedule.minutes;
              }
              if (taskTimeInput && task.schedule && task.schedule.time) {
                taskTimeInput.value = task.schedule.time;
              }
              document.querySelectorAll(".task-day").forEach((el) => {
                el.checked = task.schedule && Array.isArray(task.schedule.days)
                  ? task.schedule.days.includes(el.value)
                  : false;
              });
              updateTaskScheduleFields();
              
              // Scroll the form into view
              setTimeout(() => {
                taskForm.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
              }, 100);
            }
          } else if (action === "toggle") {
            const task = taskCache[taskId];
            const enabled = task ? !task.enabled : true;
            await fetch(`/tasks/${encodeURIComponent(taskId)}`, {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ enabled }),
            });
          } else if (action === "delete") {
            const ok = confirm("Delete this task?");
            if (ok) {
              await fetch(`/tasks/${encodeURIComponent(taskId)}`, { method: "DELETE" });
            }
          }
          flyout.classList.remove("open");
        });

        document.addEventListener("click", () => {
          const flyout = document.getElementById("taskFlyout");
          if (flyout) flyout.classList.remove("open");
        });
        window.addEventListener("scroll", () => {
          const flyout = document.getElementById("taskFlyout");
          if (flyout) flyout.classList.remove("open");
        }, true);
        window.addEventListener("resize", () => {
          const flyout = document.getElementById("taskFlyout");
          if (flyout) flyout.classList.remove("open");
        });
        window.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            const flyout = document.getElementById("taskFlyout");
            if (flyout) flyout.classList.remove("open");
          }
        });
      }

      function persistSectionState(key, collapsed) {
        try {
          localStorage.setItem(key, collapsed ? "1" : "0");
        } catch (err) {
          // ignore
        }
      }

      function restoreSectionState(toggle, body, key) {
        try {
          const val = localStorage.getItem(key);
          if (val === "1") {
            body.classList.add("collapsed");
            toggle.classList.add("collapsed");
            toggle.setAttribute("aria-expanded", "false");
          }
        } catch (err) {
          // ignore
        }
      }

      if (sessionsToggle && sessionsBody) {
        restoreSectionState(sessionsToggle, sessionsBody, "sessionsCollapsed");
        sessionsToggle.addEventListener("click", () => {
          persistSectionState("sessionsCollapsed", sessionsBody.classList.contains("collapsed"));
        });
      }
      if (tasksToggle && tasksBody) {
        restoreSectionState(tasksToggle, tasksBody, "tasksCollapsed");
        tasksToggle.addEventListener("click", () => {
          persistSectionState("tasksCollapsed", tasksBody.classList.contains("collapsed"));
        });
      }
      if (orchToggle && orchBody) {
        restoreSectionState(orchToggle, orchBody, "orchCollapsed");
        orchToggle.addEventListener("click", () => {
          persistSectionState("orchCollapsed", orchBody.classList.contains("collapsed"));
        });
      }

      function updateSessionProvider(name, provider) {
        const item = document.querySelector(`li[data-session-name="${CSS.escape(name)}"]`);
        if (!item) return;
        const tag = item.querySelector("[data-provider]");
        if (tag) tag.textContent = provider;
      }

      function updateProviderSelectState() {
        if (!providerSelect) return;
        if (!selectedSession) {
          providerSelect.disabled = true;
          return;
        }
        const running = sessionStatus && sessionStatus[selectedSession] === "running";
        providerSelect.disabled = !!running;
      }

      if (providerSelect) {
        updateProviderSelectState();
      }

      if (selectedSession && sessionStatus && sessionStatus[selectedSession] === "running") {
        attachToRunning(selectedSession);
      }
      
      // Check if we're initializing and show status message
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('initializing') === 'true' && selectedSession) {
        const initMsg = document.createElement('div');
        initMsg.className = 'message system';
        initMsg.innerHTML = '<div class="markdown"><p>🔄 <strong>Initializing session...</strong></p><p>Running /init to analyze your codebase and generate context. This may take a few minutes depending on the size of the folder.</p></div>';
        messages.appendChild(initMsg);
        scrollToBottom();
        // Clear the query param from URL without reload
        window.history.replaceState({}, '', window.location.pathname);
      }

      if (menuToggle && menuOverlay) {
        const closeMenu = () => document.body.classList.remove("menu-open");
        menuToggle.addEventListener("click", () => {
          const isMobile = window.matchMedia("(max-width: 900px)").matches;
          if (isMobile) {
            document.body.classList.toggle("menu-open");
          } else {
            document.body.classList.toggle("nav-collapsed");
          }
        });
        menuOverlay.addEventListener("click", closeMenu);
        window.addEventListener("keydown", (e) => {
          if (e.key === "Escape") closeMenu();
        });
      }

      function closeIdsModal() {
        if (idsOverlay) idsOverlay.classList.remove("open");
        if (idsModal) idsModal.classList.remove("open");
      }
      if (idsOverlay) {
        idsOverlay.addEventListener("click", closeIdsModal);
      }
      if (idsCloseBtn) {
        idsCloseBtn.addEventListener("click", closeIdsModal);
      }
      window.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          if (currentStreamAbort) {
            currentStreamAbort.abort();
            return;
          }
          closeIdsModal();
        }
      });

      function applyStatus(name, status) {
        const item = document.querySelector(`li[data-session-name="${CSS.escape(name)}"]`);
        if (!item) return;
        const dot = item.querySelector(".status-dot");
        if (!dot) return;
        if (status === "running") {
          dot.classList.add("running");
          dot.setAttribute("title", "Running");
          dot.setAttribute("aria-label", "Running");
        } else {
          dot.classList.remove("running");
          dot.setAttribute("title", "Idle");
          dot.setAttribute("aria-label", "Idle");
        }
        if (sessionStatus && typeof sessionStatus === "object") {
          sessionStatus[name] = status;
        }
        updateMasterCardStatus();
      }

      function updateMasterCardStatus() {
        const masterDot = document.querySelector(".master-card .status-dot");
        if (!masterDot || !sessionStatus || typeof sessionStatus !== "object") return;
        const running = Object.values(sessionStatus).some((value) => value === "running");
        if (running) {
          masterDot.classList.add("running");
          masterDot.setAttribute("title", "Running");
          masterDot.setAttribute("aria-label", "Running");
        } else {
          masterDot.classList.remove("running");
          masterDot.setAttribute("title", "Idle");
          masterDot.setAttribute("aria-label", "Idle");
        }
      }

      if (sessionStatus && typeof sessionStatus === "object") {
        Object.entries(sessionStatus).forEach(([name, status]) => applyStatus(name, status));
        updateProviderSelectState();
        updateMasterCardStatus();
      }

      function filterListByQuery(listEl, query) {
        if (!listEl) return;
        const q = (query || "").toLowerCase();
        let anyVisible = false;
        Array.from(listEl.querySelectorAll("li")).forEach((li) => {
          if (li.classList.contains("search-empty")) {
            li.remove();
            return;
          }
          if (li.classList.contains("muted")) {
            li.style.display = q ? "none" : "";
            return;
          }
          const text = (li.textContent || "").toLowerCase();
          const match = !q || text.includes(q);
          li.style.display = match ? "" : "none";
          if (match) anyVisible = true;
        });
        if (q && !anyVisible) {
          const empty = document.createElement("li");
          empty.className = "muted search-empty";
          empty.textContent = "No matches.";
          listEl.appendChild(empty);
        }
      }

      function applyNavFilter() {
        if (!navSearch) return;
        const q = navSearch.value || "";
        if (searchPanel) {
          searchPanel.classList.toggle("has-value", q.trim().length > 0);
        }
        filterListByQuery(document.querySelector(".sessions-list"), q);
        filterListByQuery(document.getElementById("tasksList"), q);
        filterListByQuery(document.getElementById("orchestratorsList"), q);
      }

      if (navSearch) {
        navSearch.addEventListener("input", applyNavFilter);
      }

      function renderSessions(sessions, statusMap) {
        if (!sessionsList) return;
        const sessionsPanel = document.querySelector(".sessions");
        const prevScroll = sessionsPanel ? sessionsPanel.scrollTop : 0;
        const entries = Object.entries(sessions || {});
        if (!entries.length) {
          sessionsList.innerHTML = '<li class="muted">No sessions yet.</li>';
          return;
        }
        entries.sort((a, b) => {
          const aCreated = (a[1] && a[1].created_at) ? a[1].created_at : (a[1] && a[1].last_used ? a[1].last_used : "");
          const bCreated = (b[1] && b[1].created_at) ? b[1].created_at : (b[1] && b[1].last_used ? b[1].last_used : "");
          if (aCreated !== bCreated) {
            return bCreated.localeCompare(aCreated);
          }
          return a[0].localeCompare(b[0]);
        });
        sessionsList.innerHTML = entries
          .map(([name, record]) => {
            const provider = record && record.provider ? record.provider : "codex";
            const status = statusMap && statusMap[name] ? statusMap[name] : "idle";
            const isActive = selectedSession === name ? "active" : "";
            const running = status === "running" ? "running" : "";
            const title = status === "running" ? "Running" : "Idle";
            return `
              <li class="${isActive}" data-session-name="${name}">
                <a class="session-card" href="/chat/${encodeURIComponent(name)}">
                  <div class="meta">
                    <strong>${name}</strong>
                    <span class="provider-tag" data-provider>${provider}</span>
                  </div>
                  <div class="session-actions">
                    <span class="status-dot ${running}" aria-label="${title}" title="${title}"></span>
                    <div class="session-menu" data-menu="${name}">
                      <button class="menu-btn" type="button" aria-label="Session menu">⋮</button>
                      <div class="menu-panel" role="menu">
                      <button class="menu-item has-submenu" data-model-menu="${name}">Model <span>›</span></button>
                      <button class="menu-item" data-rename="${name}">Rename</button>
                      <button class="menu-item" data-show-ids="${name}">Session IDs</button>
                      <div class="menu-ids hidden" data-ids-panel="${name}"></div>
                      <button class="menu-item danger" data-delete="${name}">Delete</button>
                      </div>
                    </div>
                  </div>
                </a>
              </li>
            `;
          })
          .join("");
        wireSessionCards();
        wireDeleteButtons();
        wireRenameButtons();
        wireShowIdsButtons();
        wireMenus();
        applyNavFilter();
        if (sessionsPanel) {
          sessionsPanel.scrollTop = prevScroll;
        }
        applyPendingNavScroll();
      }

      if (tasksList) {
        tasksList.addEventListener("click", (e) => {
          if (e.target.closest(".task-menu")) return;
          const card = e.target.closest(".task-card");
          if (!card) return;
          storeNavScroll();
        });
      }

      async function refreshSessionStatus() {
        try {
          const resp = await fetch("/sessions");
          if (!resp.ok) return;
          const data = await resp.json();
          const statusMap = data && data.status ? data.status : {};
          const sessions = data && data.sessions ? data.sessions : {};
          renderSessions(sessions, statusMap);
          Object.entries(statusMap).forEach(([name, status]) => applyStatus(name, status));
          if (selectedSession && statusMap[selectedSession]) {
            sessionStatus[selectedSession] = statusMap[selectedSession];
            updateProviderSelectState();
          }
          updateMasterCardStatus();
        } catch (err) {
          // Ignore errors
        }
      }

      function wireSessionStream() {
        if (!window.EventSource) {
          refreshSessionStatus();
          return;
        }
        const source = new EventSource("/sessions/stream");
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
          source.close();
        });
        
        source.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data || "{}");
            const statusMap = data.status || {};
            const sessions = data.sessions || {};
            renderSessions(sessions, statusMap);
            Object.entries(statusMap).forEach(([name, status]) => applyStatus(name, status));
            if (selectedSession && statusMap[selectedSession]) {
              sessionStatus[selectedSession] = statusMap[selectedSession];
              updateProviderSelectState();
            }
            updateMasterCardStatus();
          } catch (err) {
            // Ignore parse errors
          }
        };
        source.onerror = () => {
          source.close();
          refreshSessionStatus();
        };
      }

      wireSessionStream();
    </script>
  </body>
</html>

